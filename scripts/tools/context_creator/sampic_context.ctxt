===== FILE START =====
Relative Path: frontend.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/frontend.cpp
Size: 15015 bytes
-----
// ======================================================================
// SAMPIC Frontend (buffer-based, ODB-driven; controller owns collector)
// ======================================================================

// System
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <chrono>
#include <thread>
#include <mutex>
#include <memory>
#include <optional>
#include <string>
#include <unistd.h>

// MIDAS
#include "midas.h"
#include "mfe.h"

// Project: ODB + logging + FE config
#include "integration/midas/frontend_config.h"
#include "integration/midas/odb/odb_manager.h"
#include "integration/midas/odb/odb_utils.h"
#include "integration/spdlog/logger_config.h"
#include "integration/spdlog/logger_configurator.h"

// Project: SAMPIC configs + controller
#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_controller_config.h"
#include "integration/sampic/config/sampic_collector_config.h"
#include "integration/sampic/controller/sampic_controller.h"

// Event + timing structs
#include "integration/sampic/collector/sampic_event_buffer.h"

// ======================================================================
// Compact bank payloads
// ======================================================================
#pragma pack(push, 1)
struct SampicEventLite {
  uint32_t nb_hits;
  uint32_t nb_triggers;
};

// No fixed samples[] here — we write samples right after this meta.
struct SampicHitMeta {
  int32_t fe_board;
  int32_t sampic_idx;
  int32_t channel;
  int32_t hit_number;

  // number of samples that follow (uint16_t each)
  int32_t data_size;

  float   amplitude;
  float   baseline;
  float   peak;
  double  time_ns;
};
#pragma pack(pop)

// ======================================================================
// Globals (MIDAS)
// ======================================================================
const char *frontend_name       = "SAMPIC_Frontend";
const char *frontend_file_name  = __FILE__;
BOOL        frontend_call_loop  = FALSE;
INT         display_period      = 0;
INT         max_event_size      = 128 * 1024 * 1024;
INT         max_event_size_frag = 5 * max_event_size;
INT         event_buffer_size   = 5 * max_event_size;

static INT  g_frontend_index     = 0;
static char g_settings_path[256] = {0};

static bool g_system_initialized = false;

// Polling
static std::chrono::steady_clock::time_point g_last_poll_time;
static std::chrono::microseconds             g_polling_interval(1'000'000); // default 1s
static std::chrono::steady_clock::time_point g_last_evt_ts = std::chrono::steady_clock::time_point::min();

// Configs read from ODB
static FrontendConfig         g_fe_cfg;
static LoggerConfig           g_logger_cfg;
static SampicSystemSettings   g_sys_cfg;
static SampicControllerConfig g_ctrl_cfg;
static SampicCollectorConfig  g_coll_cfg;

// Controller (owns collector + buffer)
static std::unique_ptr<SampicController> g_controller;

// ======================================================================
// Prototypes
// ======================================================================
INT frontend_init(void);
INT frontend_exit(void);
INT begin_of_run(INT run_number, char *error);
INT end_of_run(INT run_number, char *error);
INT pause_run(INT run_number, char *error);
INT resume_run(INT run_number, char *error);
INT frontend_loop(void);

INT read_sampic_event(char *pevent, INT off);
INT poll_event(INT source, INT count, BOOL test);
INT interrupt_configure(INT cmd, INT source, POINTER_T adr);

// ======================================================================
// Equipment
// ======================================================================
BOOL equipment_common_overwrite = TRUE;

EQUIPMENT equipment[] = {
    {"SAMPIC %02d",
        { 1, 0,
          "SYSTEM",
          EQ_POLLED | EQ_EB,
          0,
          "MIDAS",
          TRUE,
          RO_RUNNING,
          100,
          0,
          0,
          TRUE,
          "", "", "", },
        read_sampic_event
    },
    {""}
};

// ======================================================================
// Utilities
// ======================================================================
static std::string make_bank_name(const std::string& prefix, int idx2d) {
  std::string p = prefix.empty() ? "XX" : prefix.substr(0,2);
  char name[8];
  std::snprintf(name, sizeof(name), "%s%02d", p.c_str(), idx2d);
  return std::string(name);
}

// ======================================================================
// ODB helpers
// ======================================================================
static bool initialize_all_configs_from_odb(std::string& err_out) {
  try {
    OdbManager odb;
    const std::string base = g_settings_path;

    odb.initialize(base + "/Logger", LoggerConfig{});
    g_logger_cfg = odb.read<LoggerConfig>(base + "/Logger");
    LoggerConfigurator::configure(g_logger_cfg);

    odb.initialize(base + "/Frontend", FrontendConfig{});
    g_fe_cfg = odb.read<FrontendConfig>(base + "/Frontend");

    odb.initialize(base + "/Crate", SampicSystemSettings{});
    g_sys_cfg = odb.read<SampicSystemSettings>(base + "/Crate");

    odb.initialize(base + "/Sampic Controller", SampicControllerConfig{});
    g_ctrl_cfg = odb.read<SampicControllerConfig>(base + "/Sampic Controller");

    odb.initialize(base + "/Sampic Event Collector", SampicCollectorConfig{});
    g_coll_cfg = odb.read<SampicCollectorConfig>(base + "/Sampic Event Collector");

    g_polling_interval = std::chrono::microseconds(g_fe_cfg.polling_interval_us);
    return true;
  } catch (const std::exception& e) {
    err_out = e.what();
    return false;
  }
}

static bool read_all_configs_from_odb(std::string& err_out) {
  try {
    OdbManager odb;
    const std::string base = g_settings_path;

    g_logger_cfg = odb.read<LoggerConfig>(base + "/Logger");
    g_fe_cfg     = odb.read<FrontendConfig>(base + "/Frontend");
    g_sys_cfg    = odb.read<SampicSystemSettings>(base + "/Crate");
    g_ctrl_cfg   = odb.read<SampicControllerConfig>(base + "/Sampic Controller");
    g_coll_cfg   = odb.read<SampicCollectorConfig>(base + "/Sampic Event Collector");

    LoggerConfigurator::configure(g_logger_cfg);
    g_polling_interval = std::chrono::microseconds(g_fe_cfg.polling_interval_us);
    return true;
  } catch (const std::exception& e) {
    err_out = e.what();
    return false;
  }
}

// ======================================================================
// SAMPIC controller setup
// ======================================================================
static bool initialize_sampic_controller(std::string& err_out) {
  try {
    g_controller = std::make_unique<SampicController>(g_sys_cfg, g_ctrl_cfg, g_coll_cfg);

    int rc = g_controller->initialize();
    if (rc != 0) {
      err_out = "SAMPIC controller initialize() failed with code " + std::to_string(rc);
      return false;
    }
    return true;
  } catch (const std::exception& e) {
    err_out = e.what();
    return false;
  }
}

// ======================================================================
// MIDAS Frontend impl
// ======================================================================
INT frontend_init() {
  g_frontend_index = get_frontend_index();
  std::snprintf(g_settings_path, sizeof(g_settings_path),
                "/Equipment/SAMPIC %02d/Settings", g_frontend_index);

  OdbUtils::odbSetStatusColor(g_frontend_index, g_fe_cfg.init_color);

  std::string err;
  if (!initialize_all_configs_from_odb(err)) {
    cm_msg(MERROR, __FUNCTION__, "Failed to initialize configs: %s", err.c_str());
    return FE_ERR_ODB;
  }
  if (!initialize_sampic_controller(err)) {
    cm_msg(MERROR, __FUNCTION__, "Failed to init controller: %s", err.c_str());
    return FE_ERR_HW;
  }

  g_system_initialized = true;
  OdbUtils::odbSetStatusColor(g_frontend_index, g_fe_cfg.ready_color);
  return SUCCESS;
}

INT frontend_exit() {
  try {
    if (g_controller) {
      g_controller->stopCollector();
      g_controller->stopRun();
      g_controller->cleanup();
    }
  } catch (...) {}
  g_controller.reset();
  g_system_initialized = false;
  return SUCCESS;
}

INT begin_of_run(INT run_number, char *error) {
  if (!g_system_initialized || !g_controller) {
    std::strcpy(error, "System not initialized");
    return FE_ERR_HW;
  }

  std::string err;
  if (!read_all_configs_from_odb(err)) {
    std::snprintf(error, 256, "Failed to refresh configs: %s", err.c_str());
    return FE_ERR_ODB;
  }

  g_controller->setSystemSettings(g_sys_cfg);
  g_controller->setControllerConfig(g_ctrl_cfg);
  g_controller->setCollectorConfig(g_coll_cfg);

  if (g_controller->applySettings() != 0) {
    std::strcpy(error, "Failed to apply settings");
    return FE_ERR_HW;
  }

  g_controller->startCollector();
  if (g_controller->startRun() != 0) {
    std::strcpy(error, "Failed to start run");
    return FE_ERR_HW;
  }

  g_last_evt_ts = std::chrono::steady_clock::time_point::min();
  return SUCCESS;
}

INT end_of_run(INT, char *error) {
  try {
    if (g_controller) {
      g_controller->stopCollector();
      if (g_controller->stopRun() != 0) {
        std::strcpy(error, "Failed to stop run");
        return FE_ERR_HW;
      }
    }
  } catch (...) {
    std::strcpy(error, "Error during EOR");
    return FE_ERR_HW;
  }
  return SUCCESS;
}

INT pause_run(INT, char*)  { return SUCCESS; }
INT resume_run(INT, char*) { return SUCCESS; }
INT frontend_loop()        { return SUCCESS; }

// ======================================================================
// Polling
// ======================================================================
INT poll_event(INT, INT, BOOL test) {
  if (!g_system_initialized || !g_controller) return test ? FALSE : 0;

  auto now = std::chrono::steady_clock::now();
  if (now - g_last_poll_time < g_polling_interval) return test ? FALSE : 0;
  g_last_poll_time = now;

  if (g_controller->buffer().hasNewSince(g_last_evt_ts)) return TRUE;
  return test ? FALSE : 0;
}

INT interrupt_configure(INT, INT, POINTER_T) { return SUCCESS; }

// ======================================================================
// Readout (full-waveform, variable-length hits; one ADxx + one ATxx)
// ======================================================================
INT read_sampic_event(char *pevent, INT) {
  if (!g_system_initialized || !g_controller) {
    spdlog::warn("read_sampic_event: system not initialized, skipping");
    return 0;
  }

  const auto new_events = g_controller->buffer().getSince(g_last_evt_ts);
  if (new_events.empty()) {
    spdlog::debug("read_sampic_event: no new events since last timestamp");
    return 0;
  }

  // Init MIDAS event container
  bk_init32(pevent);

  // ------------------------- DATA BANK (ADxx) -------------------------
  {
    const auto data_bank = make_bank_name(g_fe_cfg.data_bank_prefix, g_frontend_index);
    uint8_t* pdata = nullptr;
    bk_create(pevent, data_bank.c_str(), TID_UINT8, (void**)&pdata);
    uint8_t* const pdata_start = pdata;

    // Pack each collected SAMPIC event in sequence
    for (size_t iev = 0; iev < new_events.size(); ++iev) {
      const auto& tse = new_events[iev];
      if (!tse.event) {
        spdlog::warn("read_sampic_event: event {} has null pointer, skipping", iev);
        continue;
      }
      const auto ev = tse.event;

      // --- Event header ---
      const SampicEventLite evhdr{
        static_cast<uint32_t>(ev->NbOfHitsInEvent),
        static_cast<uint32_t>(ev->TriggerData.NbOfTriggers)
      };
      std::memcpy(pdata, &evhdr, sizeof(evhdr));
      pdata += sizeof(evhdr);

      spdlog::debug("Packing event {} → hits={}, triggers={}",
                    iev, evhdr.nb_hits, evhdr.nb_triggers);

      // --- Hits (variable-length) ---
      for (int i = 0; i < ev->NbOfHitsInEvent; ++i) {
        const auto& h = ev->Hit[i];

        // Choose a sane clamp to avoid corrupt banks if upstream is wrong
        // (tweak if you know chip max samples; 4096 is conservative)
        constexpr int kMaxSafeSamples = 4096;
        int data_size = std::max(0, std::min(h.DataSize, kMaxSafeSamples));

        SampicHitMeta meta{};
        meta.fe_board   = h.FeBoardIndex;
        meta.sampic_idx = h.SampicIndex;
        meta.channel    = h.Channel;
        meta.hit_number = h.HitNumber;
        meta.data_size  = data_size;
        meta.amplitude  = h.Amplitude;
        meta.baseline   = h.Baseline;
        meta.peak       = h.Peak;
        meta.time_ns    = h.TimeInstant;

        // Write meta
        std::memcpy(pdata, &meta, sizeof(meta));
        pdata += sizeof(meta);

        // Write all samples (uint16_t)
        const size_t bytes_samples = static_cast<size_t>(data_size) * sizeof(uint16_t);
        if (data_size > 0) {
          std::memcpy(pdata, h.OrderedRawDataSamples, bytes_samples);
          pdata += bytes_samples;
        }

        spdlog::trace("  hit {}: board={}, sampic={}, ch={}, hit#={}, nsamp={}, "
                      "amp={:.2f}, base={:.2f}, peak={:.2f}, t={:.3f} ns "
                      "(wrote {} + {} bytes)",
                      i, meta.fe_board, meta.sampic_idx, meta.channel, meta.hit_number,
                      meta.data_size, meta.amplitude, meta.baseline, meta.peak, meta.time_ns,
                      (int)sizeof(meta), (int)bytes_samples);
      }
    }

    bk_close(pevent, pdata);
    spdlog::debug("Closed data bank {} ({} bytes)", data_bank, (int)(pdata - pdata_start));
  }

  // ------------------------ TIMING BANK (ATxx) ------------------------
  {
    const auto timing_bank = make_bank_name(g_fe_cfg.timing_bank_prefix, g_frontend_index);
    uint8_t* ptiming = nullptr;
    bk_create(pevent, timing_bank.c_str(), TID_UINT8, (void**)&ptiming);
    uint8_t* const ptiming_start = ptiming;

    struct TimingPayload {
      uint64_t timestamp_ns;
      uint32_t prepare_us, read_us, decode_us, total_us;
    };

    for (const auto& tse : new_events) {
      TimingPayload tp;
      tp.timestamp_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                          tse.timestamp.time_since_epoch()).count();
      tp.prepare_us   = tse.timing.prepare_duration.count();
      tp.read_us      = tse.timing.read_duration.count();
      tp.decode_us    = tse.timing.decode_duration.count();
      tp.total_us     = tse.timing.total_duration.count();

      std::memcpy(ptiming, &tp, sizeof(tp));
      ptiming += sizeof(tp);

      spdlog::trace("  timing: ts={} ns, prep={}us, read={}us, dec={}us, total={}us",
                    tp.timestamp_ns, tp.prepare_us, tp.read_us, tp.decode_us, tp.total_us);
    }

    bk_close(pevent, ptiming);
    spdlog::debug("Closed timing bank {} ({} bytes)", timing_bank, (int)(ptiming - ptiming_start));
  }

  // Advance watermark
  g_last_evt_ts = new_events.back().timestamp;

  const int total_size = bk_size(pevent);
  spdlog::debug("read_sampic_event: MIDAS event size {}", total_size);
  return total_size;
}

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/midas/frontend_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/midas/frontend_config.h
Size: 780 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_MIDAS_FRONTEND_CONFIG_H
#define SAMPIC_DAQ_INTEGRATION_MIDAS_FRONTEND_CONFIG_H

#include <string>
#include <cstddef>

// Configuration for MIDAS frontend integration.
// These parameters can be populated from the ODB.
struct FrontendConfig {
    size_t min_bytes_to_trigger_on = 0;   // minimum event size in bytes
    std::string init_color = "#8A2BE2";      // initial color code for frontend GUI
    std::string ready_color = "greenLight";  // ready status color
    int polling_interval_us = 1000;          // polling interval (microseconds)
    std::string data_bank_prefix = "AD";     // prefix for data banks
    std::string timing_bank_prefix = "AT";   // prefix for timing banks
};

#endif // SAMPIC_DAQ_INTEGRATION_MIDAS_FRONTEND_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/midas/odb/odb_manager.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/midas/odb/odb_manager.h
Size: 1866 bytes
-----
#ifndef ODB_MANAGER_H
#define ODB_MANAGER_H

#include "midas.h"
#include <nlohmann/json.hpp>
#include <rfl/json.hpp>
#include <spdlog/spdlog.h>

#include <string>
#include <vector>
#include <optional>
#include <stdexcept>

using json = nlohmann::json;

extern HNDLE hDB;

class OdbManager {
public:
    explicit OdbManager(HNDLE handle = hDB) : hDB_handle(handle) {}

    // JSON/String API
    std::string read(const std::string& path);
    json read(const std::string& path, bool return_json_object);

    void write(const std::string& path, const std::string& jsonStr);
    void write(const std::string& path, const json& j);

    void initialize(const std::string& path, const std::string& jsonStr);
    void initialize(const std::string& path, const json& j);

    // Generic template API (Reflect-C++)
    template <typename T>
    T read(const std::string& path) {
        std::string jsonStr = read(path);

        auto parsed = rfl::json::read<T>(jsonStr);
        if (!parsed.has_value()) {
            spdlog::error("Failed to deserialize ODB JSON at path '{}'", path);
            throw std::runtime_error("Failed to deserialize ODB JSON at path: " + path);
        }
        return parsed.value();
    }

    template <typename T>
    void write(const std::string& path, const T& obj) {
        auto j = json::parse(rfl::json::write(obj));
        write(path, j);
    }

    template <typename T>
    void initialize(const std::string& path, const T& obj) {
        auto j = json::parse(rfl::json::write(obj));
        initialize(path, j);
    }

private:
    HNDLE hDB_handle;

    enum class OdbMode { WRITE, INITIALIZE };
    void populateOdbHelper(const std::string& basePath, const json& j, OdbMode mode);

    json removeKeysContainingKey(const json& j);
    json readRecursive(HNDLE key, const std::string& fullPath);
};

#endif // ODB_MANAGER_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/midas/odb/odb_utils.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/midas/odb/odb_utils.h
Size: 3962 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_MIDAS_ODB_UTILS_H
#define SAMPIC_DAQ_INTEGRATION_MIDAS_ODB_UTILS_H

#include "midas.h"
#include <string>
#include <vector>
#include <spdlog/spdlog.h>

extern HNDLE hDB;

class OdbUtils {
public:
    // -------------------------------
    // Common frontend helpers
    // -------------------------------
    static void odbSetStatusColor(int frontend_index, const std::string& color) {
        char path[256];
        snprintf(path, sizeof(path),
                 "/Equipment/SAMPIC %02d/Common/Status color", frontend_index);

        if (db_set_value(hDB, 0, path, color.c_str(),
                         32, 1, TID_STRING) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set status color '{}' at '{}'", color, path);
        }
    }

    static void odbSetStatusMessage(int frontend_index, const std::string& message) {
        char path[256];
        snprintf(path, sizeof(path),
                 "/Equipment/SAMPIC %02d/Common/Status", frontend_index);

        if (db_set_value(hDB, 0, path, message.c_str(),
                         256, 1, TID_STRING) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set status message '{}' at '{}'", message, path);
        }
    }

    // -------------------------------
    // Generic scalar setters
    // -------------------------------
    static void odbSetString(const std::string& path, const std::string& value) {
        if (db_set_value(hDB, 0, path.c_str(),
                         value.c_str(), value.size() + 1, 1, TID_STRING) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set string '{}={}'", path, value);
        }
    }

    static void odbSetInt(const std::string& path, int value) {
        if (db_set_value(hDB, 0, path.c_str(),
                         &value, sizeof(value), 1, TID_INT32) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set int '{}={}'", path, value);
        }
    }

    static void odbSetBool(const std::string& path, bool value) {
        int v = value ? 1 : 0;
        if (db_set_value(hDB, 0, path.c_str(),
                         &v, sizeof(v), 1, TID_BOOL) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set bool '{}={}'", path, value);
        }
    }

    static void odbSetDouble(const std::string& path, double value) {
        if (db_set_value(hDB, 0, path.c_str(),
                         &value, sizeof(value), 1, TID_DOUBLE) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set double '{}={}'", path, value);
        }
    }

    // -------------------------------
    // Array setters
    // -------------------------------
    static void odbSetIntArray(const std::string& path, const std::vector<int>& values) {
        if (db_set_value(hDB, 0, path.c_str(),
                         values.data(), values.size() * sizeof(int),
                         values.size(), TID_INT32) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set int array at '{}'", path);
        }
    }

    static void odbSetDoubleArray(const std::string& path, const std::vector<double>& values) {
        if (db_set_value(hDB, 0, path.c_str(),
                         values.data(), values.size() * sizeof(double),
                         values.size(), TID_DOUBLE) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set double array at '{}'", path);
        }
    }

    static void odbSetStringArray(const std::string& path, const std::vector<std::string>& values) {
        for (size_t i = 0; i < values.size(); ++i) {
            std::string itemPath = path + "/" + std::to_string(i);
            if (db_set_value(hDB, 0, itemPath.c_str(),
                             values[i].c_str(), values[i].size() + 1,
                             1, TID_STRING) != DB_SUCCESS) {
                spdlog::error("ODB: Failed to set string array element '{}={}'", itemPath, values[i]);
            }
        }
    }
};

#endif // SAMPIC_DAQ_INTEGRATION_MIDAS_ODB_UTILS_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/modes/sampic_collector_mode.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/modes/sampic_collector_mode.h
Size: 1095 bytes
-----
#ifndef SAMPIC_COLLECTOR_MODE_H
#define SAMPIC_COLLECTOR_MODE_H

#include "integration/sampic/collector/sampic_event_buffer.h"
#include "integration/sampic/config/sampic_collector_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
}

/// Abstract base for all SAMPIC collector modes
class SampicCollectorMode {
public:
    SampicCollectorMode(CrateInfoStruct& info,
                        CrateParamStruct& params,
                        void* eventBuffer,
                        ML_Frame* mlFrames,
                        const SampicCollectorConfig& cfg)
        : info_(info), params_(params),
          eventBuffer_(eventBuffer), mlFrames_(mlFrames),
          cfg_(cfg) {}

    virtual ~SampicCollectorMode() = default;

    /// Perform one acquisition step, filling event + timing
    virtual int readEvent(EventStruct& event,
                          SampicEventTiming& timing) = 0;

protected:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    void* eventBuffer_;
    ML_Frame* mlFrames_;
    const SampicCollectorConfig& cfg_;
};

#endif // SAMPIC_COLLECTOR_MODE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/modes/sampic_collector_mode_default.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/modes/sampic_collector_mode_default.h
Size: 794 bytes
-----
#ifndef SAMPIC_COLLECTOR_MODE_DEFAULT_H
#define SAMPIC_COLLECTOR_MODE_DEFAULT_H

#include "integration/sampic/collector/modes/sampic_collector_mode.h"

/// Default collector mode:
/// Simple Prepare → Read → Decode per event.
class SampicCollectorModeDefault : public SampicCollectorMode {
public:
    SampicCollectorModeDefault(CrateInfoStruct& info,
                               CrateParamStruct& params,
                               void* eventBuffer,
                               ML_Frame* mlFrames,
                               const SampicCollectorConfig& cfg)
        : SampicCollectorMode(info, params, eventBuffer, mlFrames, cfg) {}

    int readEvent(EventStruct& event,
                  SampicEventTiming& timing) override;
};

#endif // SAMPIC_COLLECTOR_MODE_DEFAULT_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/modes/sampic_collector_mode_example.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/modes/sampic_collector_mode_example.h
Size: 786 bytes
-----
#ifndef SAMPIC_COLLECTOR_MODE_EXAMPLE_H
#define SAMPIC_COLLECTOR_MODE_EXAMPLE_H

#include "integration/sampic/collector/modes/sampic_collector_mode.h"

/// Example mode: placeholder for testing / prototyping custom logic.
class SampicCollectorModeExample : public SampicCollectorMode {
public:
    SampicCollectorModeExample(CrateInfoStruct& info,
                               CrateParamStruct& params,
                               void* eventBuffer,
                               ML_Frame* mlFrames,
                               const SampicCollectorConfig& cfg)
        : SampicCollectorMode(info, params, eventBuffer, mlFrames, cfg) {}

    int readEvent(EventStruct& event,
                  SampicEventTiming& timing) override;
};

#endif // SAMPIC_COLLECTOR_MODE_EXAMPLE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/sampic_collector.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/sampic_collector.h
Size: 1090 bytes
-----
#ifndef SAMPIC_COLLECTOR_H
#define SAMPIC_COLLECTOR_H

#include "integration/sampic/collector/sampic_event_buffer.h"
#include "integration/sampic/config/sampic_collector_config.h"
#include "integration/sampic/collector/modes/sampic_collector_mode.h"

#include <thread>
#include <atomic>
#include <memory>
#include <spdlog/spdlog.h>

extern "C" {
#include <SAMPIC_256Ch_lib.h>
}

class SampicCollector {
public:
    SampicCollector(const SampicCollectorConfig& cfg,
                    CrateInfoStruct& info,
                    CrateParamStruct& params,
                    void* eventBuffer,
                    ML_Frame* mlFrames);
    ~SampicCollector();

    void start();
    void stop();
    bool running() const { return running_; }

    SampicEventBuffer& buffer() { return *buffer_; }
    const SampicEventBuffer& buffer() const { return *buffer_; }

private:
    void run();

    SampicCollectorConfig cfg_;
    std::unique_ptr<SampicEventBuffer> buffer_;
    std::unique_ptr<SampicCollectorMode> mode_;

    std::thread worker_;
    std::atomic<bool> running_{false};
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/sampic_event_buffer.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/sampic_event_buffer.h
Size: 1828 bytes
-----
#ifndef SAMPIC_EVENT_BUFFER_H
#define SAMPIC_EVENT_BUFFER_H

#include <deque>
#include <mutex>
#include <condition_variable>
#include <optional>
#include <chrono>
#include <vector>
#include <memory>
#include <spdlog/spdlog.h>

extern "C" {
#include <SAMPIC_256Ch_Type.h>
}

/// Timing breakdown for diagnostics
struct SampicEventTiming {
    std::chrono::microseconds prepare_duration{0};
    std::chrono::microseconds read_duration{0};
    std::chrono::microseconds decode_duration{0};
    std::chrono::microseconds total_duration{0};
};

/// Wrapper: shared_ptr to EventStruct + timestamp + timing
struct TimestampedSampicEvent {
    std::shared_ptr<EventStruct> event;
    std::chrono::steady_clock::time_point timestamp;
    SampicEventTiming timing;
    bool consumed{false};
};

/// Thread-safe buffer for holding timestamped SAMPIC events
class SampicEventBuffer {
public:
    explicit SampicEventBuffer(size_t capacity);

    // Producer
    void push(const std::shared_ptr<EventStruct>& ev, 
              const SampicEventTiming& timing);

    // Consumer
    std::optional<TimestampedSampicEvent> pop();        ///< destructive
    std::optional<TimestampedSampicEvent> latest();     ///< peek latest, marks consumed
    std::vector<TimestampedSampicEvent> getSince(std::chrono::steady_clock::time_point t);

    // Polling helpers
    bool hasNewSince(std::chrono::steady_clock::time_point t) const;
    bool waitForNew(std::chrono::steady_clock::time_point t,
                    std::chrono::milliseconds timeout);

    // Info
    size_t size() const;
    bool empty() const;

private:
    size_t capacity_;
    mutable std::mutex mtx_;
    std::condition_variable cv_;
    std::deque<TimestampedSampicEvent> buffer_;
    std::chrono::steady_clock::time_point last_timestamp_;
};

#endif // SAMPIC_EVENT_BUFFER_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_board_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_board_configurator.h
Size: 1145 bytes
-----
#ifndef SAMPIC_BOARD_CONFIGURATOR_H
#define SAMPIC_BOARD_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_chip_configurator.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicBoardConfigurator {
public:
    SampicBoardConfigurator(int boardIdx,
                            CrateInfoStruct& info,
                            CrateParamStruct& params,
                            SampicFrontEndConfig& config);

    void apply();

    void setGlobalTrigger();     // SAMPIC256CH_SetFrontEndBoardGlobalTriggerOption
    void setLevel2TriggerBuild(); // SAMPIC256CH_SetLevel2TriggerBuildOption
    void setLevel2ExtTrigGate(); // SAMPIC256CH_SetLevel2ExtTrigGate
    void setLevel2Coincidence(); // SAMPIC256CH_SetLevel2CoincidenceModeWithExtTrigGate

    void applyChips();

    // Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);
    int indexFromKey(const std::string& key);

private:
    int boardIdx_;
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicFrontEndConfig& config_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_channel_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_channel_configurator.h
Size: 1260 bytes
-----
#ifndef SAMPIC_CHANNEL_CONFIGURATOR_H
#define SAMPIC_CHANNEL_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicChannelConfigurator {
public:
    SampicChannelConfigurator(int boardIdx,
                              int chipIdx,
                              int channelIdx,
                              CrateInfoStruct& info,
                              CrateParamStruct& params,
                              SampicChannelConfig& config);

    void apply();

    void setMode();           // SAMPIC256CH_SetChannelMode
    void setTriggerMode();    // SAMPIC256CH_SetSampicChannelTriggerMode
    void setThreshold();      // SAMPIC256CH_SetSampicChannelInternalThreshold
    void setEdge();           // SAMPIC256CH_SetChannelSelflTriggerEdge
    void setSourceForCT();    // SAMPIC256CH_SetSampicChannelSourceForCT
    void setPulseMode();      // SAMPIC256CH_SetSampicChannelPulseMode

    //Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);

private:
    int boardIdx_;
    int chipIdx_;
    int channelIdx_;
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicChannelConfig& config_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_chip_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_chip_configurator.h
Size: 1486 bytes
-----
#ifndef SAMPIC_CHIP_CONFIGURATOR_H
#define SAMPIC_CHIP_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_channel_configurator.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicChipConfigurator {
public:
    SampicChipConfigurator(int boardIdx,
                           int chipIdx,
                           CrateInfoStruct& info,
                           CrateParamStruct& params,
                           SampicChipConfig& config);

    void apply();

    // Individual settings
    void setBaseline();
    void setExtThreshold();
    void setExtThresholdMode();
    void setTOTRange();
    void setTOTFilterParams();
    void setPostTrigger();
    void setCentralTriggerMode();
    void setCentralTriggerEffect();
    void setCentralTriggerPrimitives();
    void setTriggerOption();
    void setEnableTriggerMode();
    void setCommonDeadTime();
    void setPulserWidth();
    void setAdcRamp();
    void setVdacDLL();
    void setVdacDLLContinuity();
    void setVdacRosc();
    void setDllSpeedMode();
    void setOverflowDac();
    void setLvdsLowCurrent();

    void applyChannels();

    // Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);
    int indexFromKey(const std::string& key);

private:
    int boardIdx_;
    int chipIdx_;
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicChipConfig& config_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_collector_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_collector_config.h
Size: 864 bytes
-----
#ifndef SAMPIC_COLLECTOR_CONFIG_H
#define SAMPIC_COLLECTOR_CONFIG_H

#include <cstddef>
#include <string>

/// Modes for the collector loop
enum class SampicCollectorModeType {
    DEFAULT,
    EXAMPLE
};

/// Configuration for SampicCollector
struct SampicCollectorConfig {
    SampicCollectorModeType mode = SampicCollectorModeType::EXAMPLE;

    // Buffering
    size_t buffer_size = 128;      // number of events the buffer can hold

    // Timing
    int sleep_time_us = 1000000;    // microseconds to sleep between collector loop polls

    // Acquisition loop
    int soft_trigger_prepare_interval = 100;     // how often to re-call PrepareEvent
    int soft_trigger_max_loops        = 10000;   // max loops before timing out
    int soft_trigger_retry_sleep_us   = 100;     // NEW: sleep between failed read retries
};

#endif // SAMPIC_COLLECTOR_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_controller_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_controller_config.h
Size: 502 bytes
-----
#ifndef SAMPIC_CONTROLLER_CONFIG_H
#define SAMPIC_CONTROLLER_CONFIG_H

#include <cstddef>

enum class SampicInitSettingsModeType {
    DEFAULT,
    EXAMPLE
};

enum class SampicApplySettingsModeType {
    DEFAULT,
    EXAMPLE
};

struct SampicControllerConfig {
    // Independent mode switches
    SampicInitSettingsModeType  init_mode  = SampicInitSettingsModeType::DEFAULT;
    SampicApplySettingsModeType apply_mode = SampicApplySettingsModeType::DEFAULT;

};

#endif // SAMPIC_CONTROLLER_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_crate_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_crate_config.h
Size: 11336 bytes
-----
#ifndef SAMPIC_CONFIG_H
#define SAMPIC_CONFIG_H

#include <string>
#include <cstdint>
#include <map>

extern "C" {
#include <SAMPIC_256Ch_Type.h>
}

// ==============================
// Channel (lowest level)
// ==============================
struct SampicChannelConfig {
  bool enabled = true; // Setter: SAMPIC256CH_SetChannelMode | Getter: SAMPIC256CH_GetChannelMode
  SAMPIC_ChannelTriggerMode_t trigger_mode = static_cast<SAMPIC_ChannelTriggerMode_t>(3); // Setter: SAMPIC256CH_SetSampicChannelTriggerMode | Getter: SAMPIC256CH_GetSampicChannelTriggerMode
  float internal_threshold = 0.1; // Setter: SAMPIC256CH_SetSampicChannelInternalThreshold | Getter: SAMPIC256CH_GetSampicChannelInternalThreshold
  EdgeType_t trigger_edge = static_cast<EdgeType_t>(0); // Setter: SAMPIC256CH_SetChannelSelflTriggerEdge | Getter: SAMPIC256CH_GetChannelSelfTriggerEdge
  bool enable_for_central_trigger = true; // Setter: SAMPIC256CH_SetSampicChannelSourceForCT | Getter: SAMPIC256CH_GetSampicChannelSourceForCT
  bool pulse_mode = false; // Setter: SAMPIC256CH_SetSampicChannelPulseMode | Getter: SAMPIC256CH_GetSampicChannelPulseMode
};

using SampicChannelSettings = std::map<std::string, SampicChannelConfig>;

// ==============================
// Chip (contains channels)
// ==============================
struct SampicChipConfig {
  bool enabled = true; // Local enable flag (no direct setter/getter)

  float baseline_reference = 0.5; // Setter: SAMPIC256CH_SetBaselineReference | Getter: SAMPIC256CH_GetBaselineReference
  float external_threshold = 0.1; // Setter: SAMPIC256CH_SetSampicExternalThreshold | Getter: SAMPIC256CH_GetSampicExternalThreshold
  bool external_threshold_mode = false; // Setter: SAMPIC256CH_SetSampicExternalThresholdMode | Getter: SAMPIC256CH_GetSampicExternalThresholdMode
  SAMPIC_TOTRange_t tot_range = static_cast<SAMPIC_TOTRange_t>(2); // Setter: SAMPIC256CH_SetSampicTOTRange | Getter: SAMPIC256CH_GetSampicTOTRange
  bool tot_filter_enable = false; // Setter: SAMPIC256CH_SetSampicTOTFilterParams | Getter: SAMPIC256CH_GetSampicTOTFilterParams
  bool tot_wide_cap = false; // Setter: SAMPIC256CH_SetSampicTOTFilterParams | Getter: SAMPIC256CH_GetSampicTOTFilterParams
  float tot_min_width_ns = 10; // Setter: SAMPIC256CH_SetSampicTOTFilterParams | Getter: SAMPIC256CH_GetSampicTOTFilterParams
  bool enable_post_trigger = false; // Setter: SAMPIC256CH_SetSampicPostTrigParams | Getter: SAMPIC256CH_GetSampicPostTrigParams
  int post_trigger_value = 0; // Setter: SAMPIC256CH_SetSampicPostTrigParams | Getter: SAMPIC256CH_GetSampicPostTrigParams
  SampicCentralTriggerMode_t central_trigger_mode = static_cast<SampicCentralTriggerMode_t>(0); // Setter: SAMPIC256CH_SetSampicCentralTriggerMode | Getter: SAMPIC256CH_GetSampicCentralTriggerMode
  SampicCentralTriggerEffect_t central_trigger_effect = static_cast<SampicCentralTriggerEffect_t>(0); // Setter: SAMPIC256CH_SetSampicCentralTriggerEffect | Getter: SAMPIC256CH_GetSampicCentralTriggerEffect
  SAMPIC_CT_PrimitivesMode_t primitives_mode = static_cast<SAMPIC_CT_PrimitivesMode_t>(1); // Setter: SAMPIC256CH_SetSampicCentralTriggerPrimitivesOptions | Getter: SAMPIC256CH_GetSampicCentralTriggerPrimitivesOptions
  int primitives_gate_length = 5; // Setter: SAMPIC256CH_SetSampicCentralTriggerPrimitivesOptions | Getter: SAMPIC256CH_GetSampicCentralTriggerPrimitivesOptions
  SampicTriggerOption_t trigger_option = static_cast<SampicTriggerOption_t>(0); // Setter: SAMPIC256CH_SetSampicTriggerOption | Getter: SAMPIC256CH_GetSampicTriggerOption
  bool enable_trigger_use_external = false; // Setter: SAMPIC256CH_SetSampicEnableTriggerMode | Getter: SAMPIC256CH_GetSampicEnableTriggerMode
  bool enable_trigger_open_gate_on_ext = false; // Setter: SAMPIC256CH_SetSampicEnableTriggerMode | Getter: SAMPIC256CH_GetSampicEnableTriggerMode
  unsigned char enable_trigger_ext_gate = 8; // Setter: SAMPIC256CH_SetSampicEnableTriggerMode | Getter: SAMPIC256CH_GetSampicEnableTriggerMode
  bool common_dead_time = false; // Setter: SAMPIC256CH_SetSampicCommonDeadTimeMode | Getter: SAMPIC256CH_GetSampicCommonDeadTimeMode
  unsigned char pulser_width = 10; // Setter: SAMPIC256CH_SetSampicPulserWidth | Getter: SAMPIC256CH_GetSampicPulserWidth
  float adc_ramp_value = 0.045; // Setter: SAMPIC256CH_SetSampicADCRampValue | Getter: SAMPIC256CH_GetSampicADCRampValue
  float vdac_dll_value = 1.1; // Setter: SAMPIC256CH_SetSampicVdacDLLValue | Getter: SAMPIC256CH_GetSampicVdacDLLValue
  float vdac_dll_continuity = 1.1; // Setter: SAMPIC256CH_SetSampicVdacDLLContinuity | Getter: SAMPIC256CH_GetSampicVdacDLLContinuity
  float vdac_rosc = 1; // Setter: SAMPIC256CH_SetSampicVdacRosc | Getter: SAMPIC256CH_GetSampicVdacRosc
  SampicDLLModeType_t dll_speed_mode = static_cast<SampicDLLModeType_t>(3); // Setter: SAMPIC256CH_SetSampicDLLSpeedMode | Getter: SAMPIC256CH_GetSampicDLLSpeedMode
  float overflow_dac_value = 1; // Setter: SAMPIC256CH_SetSampicOverflowDacValue | Getter: SAMPIC256CH_GetSampicOverflowDacValue
  bool lvds_low_current_mode = true; // Setter: SAMPIC256CH_SetSampicLvdsLowCurrentMode | Getter: SAMPIC256CH_GetSampicLvdsLowCurrentMode

  SampicChannelSettings channels {
    {"channel0", {}}, {"channel1", {}}, {"channel2", {}}, {"channel3", {}},
    {"channel4", {}}, {"channel5", {}}, {"channel6", {}}, {"channel7", {}},
    {"channel8", {}}, {"channel9", {}}, {"channel10", {}}, {"channel11", {}},
    {"channel12", {}}, {"channel13", {}}, {"channel14", {}}, {"channel15", {}}
  };
};

using SampicChipSettings = std::map<std::string, SampicChipConfig>;

// ==============================
// Front-End Board (contains chips)
// ==============================
struct SampicFrontEndConfig {
  bool enabled = true; // Local enable flag (no direct setter/getter)

  FebGlobalTrigger_t global_trigger_option = static_cast<FebGlobalTrigger_t>(0); // Setter: SAMPIC256CH_SetFrontEndBoardGlobalTriggerOption | Getter: SAMPIC256CH_GetFrontEndBoardGlobalTriggerOption
  bool level2_trigger_build = false; // Setter: SAMPIC256CH_SetLevel2TriggerBuildOption | Getter: SAMPIC256CH_GetLevel2TriggerBuildOption
  unsigned char level2_ext_trig_gate = 8; // Setter: SAMPIC256CH_SetLevel2ExtTrigGate | Getter: SAMPIC256CH_GetLevel2ExtTrigGate
  bool level2_coincidence_ext_gate = false; // Setter: SAMPIC256CH_SetLevel2CoincidenceModeWithExtTrigGate | Getter: SAMPIC256CH_GetLevel2CoincidenceModeWithExtTrigGate
  SampicChipSettings sampics {
    {"sampic0", {}}, {"sampic1", {}}, {"sampic2", {}}, {"sampic3", {}}
  };
};

using SampicFrontEndSettings = std::map<std::string, SampicFrontEndConfig>;

// ==============================
// Crate (top-level system)
// ==============================
struct SampicSystemSettings {
  // Init parameters (not a set/get pair; carried here for ODB convenience)
  std::string ip_address = "192.168.0.4"; // via SAMPIC256CH_OpenCrateConnection
  int port = 27015;
  ConnectionType_t connection_type = static_cast<ConnectionType_t>(UDP_CONNECTION);
  ControlType_t control_type = static_cast<ControlType_t>(CTRL_AND_DAQ);
  std::string calibration_directory = "resources/calib";
  // Acquisition 
  int sampling_frequency_mhz = 6400; // Setter: SAMPIC256CH_SetSamplingFrequency | Getter: SAMPIC256CH_GetSamplingFrequency
  bool use_external_clock = false; // Setter: SAMPIC256CH_SetSamplingFrequency | Getter: SAMPIC256CH_GetSamplingFrequency
  int adc_bits = 11; // Setter: Set_SystemADCNbOfBits | Getter: Get_SystemADCNbOfBits
  bool smart_read_mode = false; // Setter: SAMPIC256CH_SetSmartReadMode | Getter: SAMPIC256CH_GetSmartReadMode
  int read_offset = 0; // Setter: SAMPIC256CH_SetSmartReadMode | Getter: SAMPIC256CH_GetSmartReadMode
  int samples_to_read = 64; // Setter: SAMPIC256CH_SetSmartReadMode | Getter: SAMPIC256CH_GetSmartReadMode
  bool enable_tot = false; // Setter: SAMPIC256CH_SetTOTMeasurementMode | Getter: SAMPIC256CH_GetTOTMeasurementMode
  int frames_per_block = 1; // Setter: SAMPIC256CH_SetNbOfFramesPerBlock | Getter: SAMPIC256CH_GetNbOfFramesPerBlock
  bool auto_conversion = true; // Setter: SAMPIC256CH_SetAutoConversionMode | Getter: SAMPIC256CH_GetAutoConversionMode
  unsigned char conversion_length = 250; // Setter: SAMPIC256CH_SetConversionLength | Getter: SAMPIC256CH_GetConversionLength

  // Triggers 
  ExternalTriggerType_t external_trigger_type = static_cast<ExternalTriggerType_t>(0); // Setter: SAMPIC256CH_SetExternalTriggerType | Getter: SAMPIC256CH_GetExternalTriggerType
  SignalLevel_t signal_level = static_cast<SignalLevel_t>(0); // Setter: SAMPIC256CH_SetExternalTriggerSigLevel | Getter: SAMPIC256CH_GetExternalTriggerSigLevel
  EdgeType_t trigger_edge = static_cast<EdgeType_t>(0); // Setter: SAMPIC256CH_SetExternalTriggerEdge | Getter: SAMPIC256CH_GetExternalTriggerEdge
  unsigned char triggers_per_event = 127; // Setter: SAMPIC256CH_SetMinNbOfTriggersPerEvent | Getter: SAMPIC256CH_GetMinNbOfTriggersPerEvent
  bool level3_trigger_build = false; // Setter: SAMPIC256CH_SetLevel3TriggerLogic | Getter: SAMPIC256CH_GetLevel3TriggerLogic
  unsigned char level3_ext_trig_gate = 8; // Setter: SAMPIC256CH_SetLevel3ExtTrigGate | Getter: SAMPIC256CH_GetLevel3ExtTrigGate
  bool level3_coincidence_ext_gate = false; // Setter: SAMPIC256CH_SetLevel3CoincidenceModeWithExtTrigGate | Getter: SAMPIC256CH_GetLevel3CoincidenceModeWithExtTrigGate
  unsigned char primitives_gate_length = 5; // Setter: SAMPIC256CH_SetPrimitivesGateLength | Getter: SAMPIC256CH_GetPrimitivesGateLength
  unsigned char latency_gate_length = 3; // Setter: SAMPIC256CH_SetLevel2LatencyGateLength | Getter: SAMPIC256CH_GetLevel2LatencyGateLength

  // External trigger counter & timestamping
  bool enable_external_trigger_counter = false; // Setter: SAMPIC256CH_SetExternalTriggerCounterMode | Getter: SAMPIC256CH_GetExternalTriggerCounterMode
  bool enable_detect_ext_trigger_id = false; // Setter: SAMPIC256CH_SetExternalTriggerCounterMode | Getter: SAMPIC256CH_GetExternalTriggerCounterMode

  // Pulser 
  bool pulser_enable = false; // Setter: SAMPIC256CH_SetPulserMode | Getter: SAMPIC256CH_GetPulserMode
  PulserSourceType_t pulser_source = static_cast<PulserSourceType_t>(0); // Setter: SAMPIC256CH_SetPulserMode | Getter: SAMPIC256CH_GetPulserMode
  bool pulser_synchronous = true; // Setter: SAMPIC256CH_SetPulserMode | Getter: SAMPIC256CH_GetPulserMode
  int pulser_period = 10; // Setter: SAMPIC256CH_SetAutoPulserPeriod | Getter: SAMPIC256CH_GetAutoPulserPeriod

  // Sync
  EdgeType_t sync_edge = static_cast<EdgeType_t>(0); // Setter: SAMPIC256CH_SetExternalSyncEdge | Getter: SAMPIC256CH_GetExternalSyncEdge
  SignalLevel_t sync_level = static_cast<SignalLevel_t>(0); // Setter: SAMPIC256CH_SetExternalSyncSigLevel | Getter: SAMPIC256CH_GetExternalSyncSigLevel

  // Corrections 
  bool adc_linearity_correction = false; // Setter: SAMPIC256CH_SetCrateCorrectionLevels | Getter: SAMPIC256CH_GetCrateCorrectionLevels
  bool time_inl_correction = false; // Setter: SAMPIC256CH_SetCrateCorrectionLevels | Getter: SAMPIC256CH_GetCrateCorrectionLevels
  bool residual_pedestal_correction = false; // Setter: SAMPIC256CH_SetCrateCorrectionLevels | Getter: SAMPIC256CH_GetCrateCorrectionLevels

  // Hierarchy (maps for ODB compatibility)
  SampicFrontEndSettings front_end_boards {
    {"feb0", {}}, {"feb1", {}}, {"feb2", {}}, {"feb3", {}}
  };
};

#endif // SAMPIC_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_crate_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_crate_configurator.h
Size: 1640 bytes
-----
#ifndef SAMPIC_CRATE_CONFIGURATOR_H
#define SAMPIC_CRATE_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_board_configurator.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicCrateConfigurator {
public:
    SampicCrateConfigurator(CrateInfoStruct& info,
                            CrateParamStruct& params,
                            SampicSystemSettings& settings);

    void apply();

    // Acquisition
    void setSamplingFrequency();     
    void setFramesPerBlock();        
    void setTOTMode();               
    void setADCBits();               
    void setSmartReadMode();         

    // External triggers
    void setExternalTriggerType();   
    void setExternalTriggerLevel();  
    void setExternalTriggerEdge();   
    void setMinTriggersPerEvent();   
    void setLevel2TriggerBuild();    
    void setLevel3TriggerBuild();    

    // Gates
    void setPrimitivesGateLength();          
    void setLevel2LatencyGateLength();       
    void setLevel3ExtTrigGate();             
    void setLevel3CoincidenceWithExtGate();  

    // Pulser
    void setPulser();                

    // Sync + corrections
    void setSyncEdge();              
    void setSyncLevel();             
    void setCorrectionLevels();      

    // Boards
    void applyBoards();

    //Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);
    int indexFromKey(const std::string& key);

private:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicSystemSettings& settings_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h
Size: 1306 bytes
-----
#ifndef SAMPIC_APPLY_SETTINGS_MODE_H
#define SAMPIC_APPLY_SETTINGS_MODE_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_crate_configurator.h"
#include "integration/sampic/config/sampic_board_configurator.h"
#include "integration/sampic/config/sampic_chip_configurator.h"
#include "integration/sampic/config/sampic_channel_configurator.h"
#include "integration/sampic/config/sampic_controller_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

/// Abstract base for all "apply settings" modes
class SampicApplySettingsMode {
public:
    SampicApplySettingsMode(CrateInfoStruct& info,
                            CrateParamStruct& params,
                            SampicSystemSettings& settings,
                            const SampicControllerConfig& controllerCfg)
        : info_(info),
          params_(params),
          settings_(settings),
          controllerCfg_(controllerCfg) {}

    virtual ~SampicApplySettingsMode() = default;

    /// Apply settings to hardware
    virtual void apply() = 0;

protected:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicSystemSettings& settings_;
    const SampicControllerConfig& controllerCfg_;
};

#endif // SAMPIC_APPLY_SETTINGS_MODE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h
Size: 461 bytes
-----
#ifndef SAMPIC_APPLY_SETTINGS_MODE_DEFAULT_H
#define SAMPIC_APPLY_SETTINGS_MODE_DEFAULT_H

#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h"

/// Default mode: applies ALL settings using configurators
class SampicApplySettingsModeDefault : public SampicApplySettingsMode {
public:
    using SampicApplySettingsMode::SampicApplySettingsMode;

    void apply() override;
};

#endif // SAMPIC_APPLY_SETTINGS_MODE_DEFAULT_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h
Size: 524 bytes
-----
#ifndef SAMPIC_APPLY_SETTINGS_MODE_EXAMPLE_H
#define SAMPIC_APPLY_SETTINGS_MODE_EXAMPLE_H

#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h"

/// Example mode: simplified trigger-only application,
/// but still through configurators so we can modify channels etc.
class SampicApplySettingsModeExample : public SampicApplySettingsMode {
public:
    using SampicApplySettingsMode::SampicApplySettingsMode;

    void apply() override;
};

#endif // SAMPIC_APPLY_SETTINGS_MODE_EXAMPLE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h
Size: 1182 bytes
-----
#ifndef SAMPIC_INIT_SETTINGS_MODE_H
#define SAMPIC_INIT_SETTINGS_MODE_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_controller_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicInitSettingsMode {
public:
    SampicInitSettingsMode(CrateInfoStruct& info,
                           CrateParamStruct& params,
                           void*& eventBuffer,
                           ML_Frame*& mlFrames,
                           const SampicSystemSettings& settings,
                           const SampicControllerConfig& controllerCfg)
        : info_(info),
          params_(params),
          eventBuffer_(eventBuffer),
          mlFrames_(mlFrames),
          settings_(settings),
          controllerCfg_(controllerCfg) {}

    virtual ~SampicInitSettingsMode() = default;

    virtual int initialize() = 0;

protected:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    void*& eventBuffer_;
    ML_Frame*& mlFrames_;
    const SampicSystemSettings& settings_;
    const SampicControllerConfig& controllerCfg_;
};

#endif // SAMPIC_INIT_SETTINGS_MODE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h
Size: 396 bytes
-----
#ifndef SAMPIC_INIT_SETTINGS_MODE_DEFAULT_H
#define SAMPIC_INIT_SETTINGS_MODE_DEFAULT_H

#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h"

class SampicInitSettingsModeDefault : public SampicInitSettingsMode {
public:
    using SampicInitSettingsMode::SampicInitSettingsMode;
    int initialize() override;
};

#endif // SAMPIC_INIT_SETTINGS_MODE_DEFAULT_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h
Size: 396 bytes
-----
#ifndef SAMPIC_INIT_SETTINGS_MODE_EXAMPLE_H
#define SAMPIC_INIT_SETTINGS_MODE_EXAMPLE_H

#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h"

class SampicInitSettingsModeExample : public SampicInitSettingsMode {
public:
    using SampicInitSettingsMode::SampicInitSettingsMode;
    int initialize() override;
};

#endif // SAMPIC_INIT_SETTINGS_MODE_EXAMPLE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/sampic_controller.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/sampic_controller.h
Size: 2792 bytes
-----
#ifndef SAMPIC_CONTROLLER_H
#define SAMPIC_CONTROLLER_H

#include <memory>
#include <spdlog/spdlog.h>

// External SAMPIC lib
extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

// Project configs + components
#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_controller_config.h"
#include "integration/sampic/config/sampic_collector_config.h"
#include "integration/sampic/collector/sampic_collector.h"
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h"
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h"

/// High-level orchestrator for SAMPIC system
class SampicController {
public:
    SampicController(const SampicSystemSettings& sys_cfg,
                     const SampicControllerConfig& ctrl_cfg,
                     const SampicCollectorConfig& coll_cfg);

    ~SampicController();

    // ---------------- Config management ----------------
    void setSystemSettings(const SampicSystemSettings& s);
    SampicSystemSettings& systemSettings();
    const SampicSystemSettings& systemSettings() const;

    void setControllerConfig(const SampicControllerConfig& c);
    SampicControllerConfig& controllerConfig();
    const SampicControllerConfig& controllerConfig() const;

    void setCollectorConfig(const SampicCollectorConfig& c);
    SampicCollectorConfig& collectorConfig();
    const SampicCollectorConfig& collectorConfig() const;

    // ---------------- Lifecycle ----------------
    int initialize();       ///< Initialize hardware (crate connection, params, calib, memory)
    int applySettings();    ///< Apply settings (trigger options etc.)
    int startRun();         ///< Start acquisition
    int stopRun();          ///< Stop acquisition
    void cleanup();         ///< Free resources, close connection

    // ---------------- Collector ----------------
    void startCollector();
    void stopCollector();

    // ---------------- Buffer access ----------------
    SampicEventBuffer& buffer();
    const SampicEventBuffer& buffer() const;

private:
    // Configs
    SampicSystemSettings   settings_;
    SampicControllerConfig ctrl_cfg_;
    SampicCollectorConfig  coll_cfg_;

    // Hardware handles
    CrateInfoStruct info_{};
    CrateParamStruct params_{};
    void* eventBuffer_{nullptr};
    ML_Frame* mlFrames_{nullptr};

    // Collector (owns its buffer)
    std::unique_ptr<SampicCollector> collector_;

    // Init/apply strategies
    std::unique_ptr<SampicInitSettingsMode> init_mode_;
    std::unique_ptr<SampicApplySettingsMode> apply_mode_;

    // State
    bool initialized_{false};
    bool run_started_{false};
    bool collector_running_{false};
};

#endif // SAMPIC_CONTROLLER_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/spdlog/logger_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/spdlog/logger_config.h
Size: 939 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIG_H
#define SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIG_H

#include <string>

// Configuration for spdlog logger setup.
// Define parameters to be read from ODB or config files.
struct LoggerConfig {
    std::string name = "SAMPIC_DAQ";         // logger name (shows up in [%n])
    std::string log_level = "info";         // e.g., "trace", "debug", "info", "warn", "error"
    std::string log_pattern = "[%T] [%^%l%$] [%n] %v"; // include [%n] for logger name
    std::string log_file = "frontend.log";  // optional log file path
    bool to_console = true;                 // enable logging to console
    bool to_file = false;                   // enable logging to file
    size_t max_file_size = 5 * 1024 * 1024; // 5 MB for rotating file sink
    size_t max_files = 3;                   // number of rotated files to keep
};


#endif // SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/spdlog/logger_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/spdlog/logger_configurator.h
Size: 454 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIGURATOR_H
#define SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIGURATOR_H

#include "integration/spdlog/logger_config.h"

class LoggerConfigurator {
public:
    // Configure global spdlog default logger from ODB/struct settings
    static void configure(const LoggerConfig& cfg);

private:
    LoggerConfigurator() = default; // no instances
};

#endif // SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIGURATOR_H

===== FILE END =====

===== FILE START =====
Relative Path: include/processing/sampic_processing/collector/frontend_event_buffer.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/processing/sampic_processing/collector/frontend_event_buffer.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: include/processing/sampic_processing/collector/frontend_event_collector.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/processing/sampic_processing/collector/frontend_event_collector.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: include/processing/sampic_processing/config/frontend_event_collector_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/processing/sampic_processing/config/frontend_event_collector_config.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/midas/odb/odb_manager.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/midas/odb/odb_manager.cpp
Size: 8658 bytes
-----
#include "integration/midas/odb/odb_manager.h"
#include <cstring>

// --- JSON/String API ---
std::string OdbManager::read(const std::string& path) {
    json j = read(path, false);
    return j.dump();
}

json OdbManager::read(const std::string& path, bool /*unused*/) {
    HNDLE key;
    if (db_find_key(hDB_handle, 0, path.c_str(), &key) != DB_SUCCESS) {
        // Commented out because this is sometimes expected behavior
        // spdlog::warn("ODB key '{}' not found", path);
        return nullptr;
    }
    return readRecursive(key, path);
}

// --- Recursive reader with full path ---
json OdbManager::readRecursive(HNDLE key, const std::string& fullPath) {
    json result;

    INT type = 0, num_values = 0, item_size = 0;
    char name[128] = {0};

    INT ret = db_get_key_info(hDB_handle, key, name, sizeof(name), &type, &num_values, &item_size);
    if (ret != DB_SUCCESS) {
        spdlog::error("db_get_key_info failed for path '{}'", fullPath);
        return result;
    }

    // Container keys (struct/array) or any node with subkeys
    HNDLE subkey;
    INT idx = 0;
    bool hasSubkeys = false;
    while (db_enum_key(hDB_handle, key, idx, &subkey) == DB_SUCCESS) {
        hasSubkeys = true;
        char subname[128] = {0};
        INT sub_type = 0, sub_num_values = 0, sub_item_size = 0;
        if (db_get_key_info(hDB_handle, subkey, subname, sizeof(subname),
                            &sub_type, &sub_num_values, &sub_item_size) == DB_SUCCESS) {
            std::string subPath = fullPath + "/" + subname;
            result[subname] = readRecursive(subkey, subPath);
        }
        ++idx;
    }

    if (hasSubkeys)
        return result;

    // Scalar leaf keys
    switch (type) {
        case TID_UINT8: case TID_INT8: case TID_UINT16: case TID_INT16:
        case TID_UINT32: case TID_INT32: case TID_INT64: case TID_UINT64: {
            int64_t val = 0;
            int read_size = item_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), &val, &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = val;
            else spdlog::error("db_get_value failed for path '{}' (int)", fullPath);
            break;
        }
        case TID_FLOAT32: case TID_FLOAT64: {
            double val = 0;
            int read_size = item_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), &val, &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = val;
            else spdlog::error("db_get_value failed for path '{}' (float)", fullPath);
            break;
        }
        case TID_BOOL: {
            int val = 0;
            int read_size = item_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), &val, &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = (val != 0);
            else spdlog::error("db_get_value failed for path '{}' (bool)", fullPath);
            break;
        }
        case TID_STRING: {
            int buf_size = std::max(item_size, 1);
            std::vector<char> buf(buf_size, 0);
            int read_size = buf_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), buf.data(), &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = std::string(buf.data(), read_size);
            else spdlog::error("db_get_value failed for path '{}' (string)", fullPath);
            break;
        }
        default:
            spdlog::warn("Unsupported ODB type {} at path '{}'", type, fullPath);
            break;
    }

    return result;
}

// --- Write / Initialize API ---
void OdbManager::write(const std::string& path, const std::string& jsonStr) {
    write(path, json::parse(jsonStr));
}

void OdbManager::write(const std::string& path, const json& j) {
    spdlog::info("Writing to ODB at '{}'", path);
    populateOdbHelper(path, j, OdbMode::WRITE);
}

void OdbManager::initialize(const std::string& path, const std::string& jsonStr) {
    initialize(path, json::parse(jsonStr));
}

void OdbManager::initialize(const std::string& path, const json& j) {
    // Don't need this info, plus we need to call this before logger is initialized
    // spdlog::info("Initializing ODB at '{}'", path); 
    populateOdbHelper(path, j, OdbMode::INITIALIZE);
}

// --- Populate ODB recursively ---
void OdbManager::populateOdbHelper(const std::string& basePath, const json& j, OdbMode mode) {
    HNDLE key;
    bool exists = (db_find_key(hDB_handle, 0, basePath.c_str(), &key) == DB_SUCCESS);

    if (j.is_object()) {
        // Ensure directory key exists
        if (!exists && mode == OdbMode::INITIALIZE) {
            db_create_key(hDB_handle, 0, basePath.c_str(), TID_KEY);
        }
        // Recurse on object fields
        for (auto& [subkey, value] : j.items()) {
            std::string fullPath = basePath + "/" + subkey;
            populateOdbHelper(fullPath, value, mode);
        }
    }
    else if (j.is_array()) {
        if (j.empty()) return;

        // Ensure array key exists
        if (!exists && mode == OdbMode::INITIALIZE) {
            db_create_key(hDB_handle, 0, basePath.c_str(), TID_KEY);
        }

        // Detect primitive array vs object array
        if (j.front().is_primitive()) {
            if (mode == OdbMode::INITIALIZE && exists) {
                return; // skip existing arrays
            }

            if (j.front().is_string()) {
                std::vector<std::string> vals;
                for (auto& v : j) vals.push_back(v.get<std::string>());
                for (size_t i = 0; i < vals.size(); i++) {
                    std::string itemPath = basePath + "/" + std::to_string(i);
                    db_set_value(hDB_handle, 0, itemPath.c_str(),
                                 vals[i].c_str(), vals[i].size() + 1, 1, TID_STRING);
                }
            }
            else if (j.front().is_boolean()) {
                std::vector<int> vals;
                for (auto& v : j) vals.push_back(v.get<bool>() ? 1 : 0);
                db_set_value(hDB_handle, 0, basePath.c_str(),
                             vals.data(), sizeof(int) * vals.size(), vals.size(), TID_BOOL);
            }
            else if (j.front().is_number_float()) {
                std::vector<double> vals;
                for (auto& v : j) vals.push_back(v.get<double>());
                db_set_value(hDB_handle, 0, basePath.c_str(),
                             vals.data(), sizeof(double) * vals.size(), vals.size(), TID_FLOAT64);
            }
            else if (j.front().is_number_integer()) {
                std::vector<int64_t> vals;
                for (auto& v : j) vals.push_back(v.get<int64_t>());
                db_set_value(hDB_handle, 0, basePath.c_str(),
                             vals.data(), sizeof(int64_t) * vals.size(), vals.size(), TID_INT64);
            }
        }
        else {
            // Array of objects → recurse
            for (size_t i = 0; i < j.size(); ++i) {
                std::string itemPath = basePath + "/" + std::to_string(i);
                populateOdbHelper(itemPath, j[i], mode);
            }
        }
    }
    else if (j.is_primitive()) {
        // Skip existing values in INITIALIZE mode
        if (mode == OdbMode::INITIALIZE && exists) {
            return;
        }

        // Scalars
        if (j.is_string()) {
            std::string s = j;
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         s.c_str(), s.size() + 1, 1, TID_STRING);
        }
        else if (j.is_boolean()) {
            int b = j.get<bool>() ? 1 : 0;
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         &b, sizeof(int), 1, TID_BOOL);
        }
        else if (j.is_number_float()) {
            double d = j.get<double>();
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         &d, sizeof(double), 1, TID_FLOAT64);
        }
        else if (j.is_number_integer()) {
            int64_t v = j.get<int64_t>();
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         &v, sizeof(int64_t), 1, TID_INT64);
        }
    }
}



// --- Utility ---
json OdbManager::removeKeysContainingKey(const json& j) {
    json result = j;
    for (auto it = result.begin(); it != result.end(); ) {
        if (it.key().find("/key") != std::string::npos) {
            spdlog::debug("Removing JSON key '{}'", it.key());
            it = result.erase(it);
        } else {
            if (it.value().is_object() || it.value().is_array()) {
                it.value() = removeKeysContainingKey(it.value());
            }
            ++it;
        }
    }
    return result;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/modes/sampic_collector_mode_default.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/modes/sampic_collector_mode_default.cpp
Size: 2816 bytes
-----
#include "integration/sampic/collector/modes/sampic_collector_mode_default.h"
#include <spdlog/spdlog.h>
#include <thread>   // for sleep_for

int SampicCollectorModeDefault::readEvent(EventStruct& event,
                                          SampicEventTiming& timing) {
    auto t_start = std::chrono::steady_clock::now();
    SAMPIC256CH_PrepareEvent(&info_, &params_);
    auto t_after_prepare = std::chrono::steady_clock::now();

    SAMPIC256CH_ErrCode errCode = SAMPIC256CH_NoFrameRead;
    int numberOfHits = 0;
    int nframes = 0;
    int dummy = 0;
    int nloop_for_soft_trig = 0;

    while (errCode != SAMPIC256CH_Success) {
        auto t_read_start = std::chrono::steady_clock::now();
        errCode = SAMPIC256CH_ReadEventBuffer(&info_, dummy, eventBuffer_, mlFrames_, &nframes);
        auto t_read_end = std::chrono::steady_clock::now();

        if (errCode == SAMPIC256CH_Success) {
            auto t_decode_start = std::chrono::steady_clock::now();
            errCode = SAMPIC256CH_DecodeEvent(&info_, &params_, mlFrames_, &event, nframes, &numberOfHits);
            auto t_decode_end = std::chrono::steady_clock::now();

            timing.decode_duration =
                std::chrono::duration_cast<std::chrono::microseconds>(t_decode_end - t_decode_start);
        }

        timing.read_duration +=
            std::chrono::duration_cast<std::chrono::microseconds>(t_read_end - t_read_start);

        if (errCode == SAMPIC256CH_AcquisitionError || errCode == SAMPIC256CH_ErrInvalidEvent) {
            spdlog::error("Default mode: Acquisition error (err={})", static_cast<int>(errCode));
            return -1;
        }

        if ((nloop_for_soft_trig % cfg_.soft_trigger_prepare_interval) == 0) {
            SAMPIC256CH_PrepareEvent(&info_, &params_);
        }
        nloop_for_soft_trig++;

        if (nloop_for_soft_trig > cfg_.soft_trigger_max_loops) {
            spdlog::warn("Default mode: Timeout after {} loops", cfg_.soft_trigger_max_loops);
            return 0;
        }

        // NEW: avoid pegging CPU if repeated failures
        if (errCode != SAMPIC256CH_Success && cfg_.soft_trigger_retry_sleep_us > 0) {
            std::this_thread::sleep_for(
                std::chrono::microseconds(cfg_.soft_trigger_retry_sleep_us));
        }
    }

    timing.prepare_duration =
        std::chrono::duration_cast<std::chrono::microseconds>(t_after_prepare - t_start);

    if (errCode == SAMPIC256CH_Success && numberOfHits > 0) {
        spdlog::debug("Default mode: Collected {} hits (prepare={}us, read={}us, decode={}us)",
                      numberOfHits,
                      timing.prepare_duration.count(),
                      timing.read_duration.count(),
                      timing.decode_duration.count());
    }

    return numberOfHits;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/modes/sampic_collector_mode_example.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/modes/sampic_collector_mode_example.cpp
Size: 2816 bytes
-----
#include "integration/sampic/collector/modes/sampic_collector_mode_example.h"
#include <spdlog/spdlog.h>
#include <thread>   // for sleep_for

int SampicCollectorModeExample::readEvent(EventStruct& event,
                                          SampicEventTiming& timing) {
    auto t_start = std::chrono::steady_clock::now();
    SAMPIC256CH_PrepareEvent(&info_, &params_);
    auto t_after_prepare = std::chrono::steady_clock::now();

    SAMPIC256CH_ErrCode errCode = SAMPIC256CH_NoFrameRead;
    int numberOfHits = 0;
    int nframes = 0;
    int dummy = 0;
    int nloop_for_soft_trig = 0;

    while (errCode != SAMPIC256CH_Success) {
        auto t_read_start = std::chrono::steady_clock::now();
        errCode = SAMPIC256CH_ReadEventBuffer(&info_, dummy, eventBuffer_, mlFrames_, &nframes);
        auto t_read_end = std::chrono::steady_clock::now();

        if (errCode == SAMPIC256CH_Success) {
            auto t_decode_start = std::chrono::steady_clock::now();
            errCode = SAMPIC256CH_DecodeEvent(&info_, &params_, mlFrames_, &event, nframes, &numberOfHits);
            auto t_decode_end = std::chrono::steady_clock::now();

            timing.decode_duration =
                std::chrono::duration_cast<std::chrono::microseconds>(t_decode_end - t_decode_start);
        }

        timing.read_duration +=
            std::chrono::duration_cast<std::chrono::microseconds>(t_read_end - t_read_start);

        if (errCode == SAMPIC256CH_AcquisitionError || errCode == SAMPIC256CH_ErrInvalidEvent) {
            spdlog::error("Example mode: Acquisition error (err={})", static_cast<int>(errCode));
            return -1;
        }

        if ((nloop_for_soft_trig % cfg_.soft_trigger_prepare_interval) == 0) {
            SAMPIC256CH_PrepareEvent(&info_, &params_);
        }
        nloop_for_soft_trig++;

        if (nloop_for_soft_trig > cfg_.soft_trigger_max_loops) {
            spdlog::warn("Example mode: Timeout after {} loops", cfg_.soft_trigger_max_loops);
            return 0;
        }

        // NEW: avoid pegging CPU if repeated failures
        if (errCode != SAMPIC256CH_Success && cfg_.soft_trigger_retry_sleep_us > 0) {
            std::this_thread::sleep_for(
                std::chrono::microseconds(cfg_.soft_trigger_retry_sleep_us));
        }
    }

    timing.prepare_duration =
        std::chrono::duration_cast<std::chrono::microseconds>(t_after_prepare - t_start);

    if (errCode == SAMPIC256CH_Success && numberOfHits > 0) {
        spdlog::debug("Example mode: Collected {} hits (prepare={}us, read={}us, decode={}us)",
                      numberOfHits,
                      timing.prepare_duration.count(),
                      timing.read_duration.count(),
                      timing.decode_duration.count());
    }

    return numberOfHits;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/sampic_collector.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/sampic_collector.cpp
Size: 2125 bytes
-----
#include "integration/sampic/collector/sampic_collector.h"
#include "integration/sampic/collector/modes/sampic_collector_mode_default.h"
#include "integration/sampic/collector/modes/sampic_collector_mode_example.h"

SampicCollector::SampicCollector(const SampicCollectorConfig& cfg,
                                 CrateInfoStruct& info,
                                 CrateParamStruct& params,
                                 void* eventBuffer,
                                 ML_Frame* mlFrames)
    : cfg_(cfg),
      buffer_(std::make_unique<SampicEventBuffer>(cfg.buffer_size)) {
    switch (cfg.mode) {
        case SampicCollectorModeType::DEFAULT:
            mode_ = std::make_unique<SampicCollectorModeDefault>(info, params, eventBuffer, mlFrames, cfg);
            break;
        case SampicCollectorModeType::EXAMPLE:
            mode_ = std::make_unique<SampicCollectorModeExample>(info, params, eventBuffer, mlFrames, cfg);
            break;
        default:
            throw std::runtime_error("Unsupported SampicCollectorModeType");
    }
}

SampicCollector::~SampicCollector() {
    stop();
}

void SampicCollector::start() {
    if (running_) return;
    running_ = true;
    worker_ = std::thread(&SampicCollector::run, this);
}

void SampicCollector::stop() {
    if (running_) {
        running_ = false;
        if (worker_.joinable()) worker_.join();
    }
}

void SampicCollector::run() {
    spdlog::info("SAMPIC Collector started in mode {}", static_cast<int>(cfg_.mode));
    while (running_) {
        auto start_total = std::chrono::steady_clock::now();
        SampicEventTiming timing{};
        auto ev_ptr = std::make_shared<EventStruct>();

        int hits = mode_->readEvent(*ev_ptr, timing);

        auto end_total = std::chrono::steady_clock::now();
        timing.total_duration = std::chrono::duration_cast<std::chrono::microseconds>(end_total - start_total);

        if (hits > 0) {
            buffer_->push(ev_ptr, timing);
        }

        std::this_thread::sleep_for(std::chrono::microseconds(cfg_.sleep_time_us));
    }
    spdlog::info("SAMPIC Collector stopped");
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/sampic_event_buffer.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/sampic_event_buffer.cpp
Size: 2777 bytes
-----
#include "integration/sampic/collector/sampic_event_buffer.h"

SampicEventBuffer::SampicEventBuffer(size_t capacity)
    : capacity_(capacity),
      last_timestamp_(std::chrono::steady_clock::time_point::min()) {}

void SampicEventBuffer::push(const std::shared_ptr<EventStruct>& ev,
                             const SampicEventTiming& timing) {
    std::unique_lock<std::mutex> lock(mtx_);
    if (buffer_.size() >= capacity_) {
        const auto& oldest = buffer_.front();
        if (!oldest.consumed) {
            auto ts_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                             oldest.timestamp.time_since_epoch())
                             .count();
            spdlog::warn("SampicEventBuffer full ({}). Dropping UNCONSUMED event ts={} ns",
                         capacity_, ts_ns);
        }
        buffer_.pop_front();
    }
    buffer_.push_back(TimestampedSampicEvent{
        ev, std::chrono::steady_clock::now(), timing, false});
    last_timestamp_ = buffer_.back().timestamp;
    cv_.notify_all();
}

std::optional<TimestampedSampicEvent> SampicEventBuffer::pop() {
    std::unique_lock<std::mutex> lock(mtx_);
    if (buffer_.empty()) return std::nullopt;
    auto ev = buffer_.front();
    buffer_.pop_front();
    return ev;
}

std::optional<TimestampedSampicEvent> SampicEventBuffer::latest() {
    std::unique_lock<std::mutex> lock(mtx_);
    if (buffer_.empty()) return std::nullopt;
    auto& ev = buffer_.back();
    if (ev.consumed) {
        spdlog::warn("latest() returning already-consumed event");
    }
    ev.consumed = true;
    return ev;
}

std::vector<TimestampedSampicEvent>
SampicEventBuffer::getSince(std::chrono::steady_clock::time_point t) {
    std::unique_lock<std::mutex> lock(mtx_);
    std::vector<TimestampedSampicEvent> result;
    for (auto& ev : buffer_) {
        if (ev.timestamp > t) {
            if (ev.consumed) {
                spdlog::warn("getSince(): event already consumed");
            }
            ev.consumed = true;
            result.push_back(ev);
        }
    }
    return result;
}

bool SampicEventBuffer::hasNewSince(std::chrono::steady_clock::time_point t) const {
    std::unique_lock<std::mutex> lock(mtx_);
    return last_timestamp_ > t;
}

bool SampicEventBuffer::waitForNew(std::chrono::steady_clock::time_point t,
                                   std::chrono::milliseconds timeout) {
    std::unique_lock<std::mutex> lock(mtx_);
    return cv_.wait_for(lock, timeout, [&] {
        return last_timestamp_ > t;
    });
}

size_t SampicEventBuffer::size() const {
    std::unique_lock<std::mutex> lock(mtx_);
    return buffer_.size();
}

bool SampicEventBuffer::empty() const {
    std::unique_lock<std::mutex> lock(mtx_);
    return buffer_.empty();
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_board_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_board_configurator.cpp
Size: 4554 bytes
-----
#include "integration/sampic/config/sampic_board_configurator.h"
#include "integration/sampic/config/sampic_chip_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>

// ------------------- Ctor -------------------
SampicBoardConfigurator::SampicBoardConfigurator(int boardIdx,
                                                 CrateInfoStruct& info,
                                                 CrateParamStruct& params,
                                                 SampicFrontEndConfig& config)
    : boardIdx_(boardIdx), info_(info), params_(params), config_(config) {}

// ------------------- Apply -------------------
void SampicBoardConfigurator::apply() {
    if (!config_.enabled) {
        spdlog::info("FEB {} disabled in config → skipping.", boardIdx_);
        return;
    }

    spdlog::debug("Applying FEB {} settings...", boardIdx_);

    setGlobalTrigger();
    setLevel2TriggerBuild();
    setLevel2ExtTrigGate();
    setLevel2Coincidence();

    applyChips();

    spdlog::debug("Finished applying FEB {}.", boardIdx_);
}

// ------------------- Settings -------------------
void SampicBoardConfigurator::setGlobalTrigger() {
    FebGlobalTrigger_t current{};
    check(SAMPIC256CH_GetFrontEndBoardGlobalTriggerOption(&params_, boardIdx_, &current),
          "GetFrontEndBoardGlobalTriggerOption");

    if (current == config_.global_trigger_option) return;

    check(SAMPIC256CH_SetFrontEndBoardGlobalTriggerOption(&info_, &params_,
                                                          boardIdx_,
                                                          config_.global_trigger_option),
          "SetFrontEndBoardGlobalTriggerOption");
}

void SampicBoardConfigurator::setLevel2TriggerBuild() {
    Boolean current{};
    check(SAMPIC256CH_GetLevel2TriggerBuildOption(&params_, &current),
          "GetLevel2TriggerBuildOption");

    Boolean desired = config_.level2_trigger_build ? TRUE : FALSE;
    if (current == desired) return;

    check(SAMPIC256CH_SetLevel2TriggerBuildOption(&info_, &params_, desired),
          "SetLevel2TriggerBuildOption");
}

void SampicBoardConfigurator::setLevel2ExtTrigGate() {
    unsigned char current{};
    check(SAMPIC256CH_GetLevel2ExtTrigGate(&params_, boardIdx_, &current),
          "GetLevel2ExtTrigGate");

    if (current == config_.level2_ext_trig_gate) return;

    check(SAMPIC256CH_SetLevel2ExtTrigGate(&info_, &params_,
                                           boardIdx_,
                                           config_.level2_ext_trig_gate),
          "SetLevel2ExtTrigGate");
}

void SampicBoardConfigurator::setLevel2Coincidence() {
    Boolean current{};
    check(SAMPIC256CH_GetLevel2CoincidenceModeWithExtTrigGate(&params_, boardIdx_, &current),
          "GetLevel2CoincidenceModeWithExtTrigGate");

    Boolean desired = config_.level2_coincidence_ext_gate ? TRUE : FALSE;
    if (current == desired) return;

    check(SAMPIC256CH_SetLevel2CoincidenceModeWithExtTrigGate(&info_, &params_,
                                                              boardIdx_,
                                                              desired),
          "SetLevel2CoincidenceModeWithExtTrigGate");
}

// ------------------- Chips descend -------------------
void SampicBoardConfigurator::applyChips() {
    spdlog::debug("FEB {}: applying {} chips...", boardIdx_, config_.sampics.size());
    for (auto& [chipKey, chipCfg] : config_.sampics) {
        int chipIdx = indexFromKey(chipKey);

        if (!chipCfg.enabled) {
            spdlog::info("Skipping chip '{}' (FEB={}, idx={}) — disabled.",
                         chipKey, boardIdx_, chipIdx);
            continue;
        }

        SampicChipConfigurator chip(boardIdx_, chipIdx, info_, params_, chipCfg);
        chip.apply();
    }
}

// ------------------- Utility -------------------
void SampicBoardConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error (FEB {}) in {} (code={})",
                      boardIdx_, what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

int SampicBoardConfigurator::indexFromKey(const std::string& key) {
    size_t pos = key.find_last_not_of("0123456789");
    if (pos == std::string::npos || pos + 1 >= key.size()) {
        throw std::runtime_error("Invalid config key: " + key);
    }
    return std::stoi(key.substr(pos + 1));
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_channel_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_channel_configurator.cpp
Size: 7802 bytes
-----
#include "integration/sampic/config/sampic_channel_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>

// ------------------- Ctor -------------------
SampicChannelConfigurator::SampicChannelConfigurator(int boardIdx,
                                                     int chipIdx,
                                                     int channelIdx,
                                                     CrateInfoStruct& info,
                                                     CrateParamStruct& params,
                                                     SampicChannelConfig& config)
    : boardIdx_(boardIdx), chipIdx_(chipIdx), channelIdx_(channelIdx),
      info_(info), params_(params), config_(config) {}

// ------------------- Apply -------------------
void SampicChannelConfigurator::apply() {
    spdlog::debug("Applying channel (FEB={}, chip={}, ch={}) settings...",
                  boardIdx_, chipIdx_, channelIdx_);

    setMode();
    setTriggerMode();
    setThreshold();
    setEdge();
    setSourceForCT();
    setPulseMode();

    spdlog::debug("Finished applying channel (FEB={}, chip={}, ch={}).",
                  boardIdx_, chipIdx_, channelIdx_);
}

// ------------------- Settings -------------------
void SampicChannelConfigurator::setMode() {
    Boolean current{};
    check(SAMPIC256CH_GetChannelMode(&params_,
                                     boardIdx_,
                                     chipIdx_ * 16 + channelIdx_,
                                     &current),
          "GetChannelMode");

    if ((bool)current == config_.enabled) {
        spdlog::trace("Channel (FEB={}, chip={}, ch={}): Mode already {} -> skip",
                      boardIdx_, chipIdx_, channelIdx_, (bool)current);
        return;
    }

    spdlog::trace("Channel (FEB={}, chip={}, ch={}): Changing Mode {} -> {}",
                  boardIdx_, chipIdx_, channelIdx_, (bool)current, config_.enabled);

    check(SAMPIC256CH_SetChannelMode(&info_, &params_,
                                     boardIdx_,
                                     chipIdx_ * 16 + channelIdx_,
                                     config_.enabled),
          "SetChannelMode");
}

void SampicChannelConfigurator::setTriggerMode() {
    SAMPIC_ChannelTriggerMode_t current{};
    check(SAMPIC256CH_GetSampicChannelTriggerMode(&params_,
                                                  boardIdx_, chipIdx_, channelIdx_,
                                                  &current),
          "GetSampicChannelTriggerMode");

    if (current == config_.trigger_mode) {
        spdlog::trace("Channel (FEB={}, chip={}, ch={}): TriggerMode already {} -> skip",
                      boardIdx_, chipIdx_, channelIdx_, (int)current);
        return;
    }

    spdlog::trace("Channel (FEB={}, chip={}, ch={}): Changing TriggerMode {} -> {}",
                  boardIdx_, chipIdx_, channelIdx_, (int)current, (int)config_.trigger_mode);

    check(SAMPIC256CH_SetSampicChannelTriggerMode(&info_, &params_,
                                                  boardIdx_, chipIdx_, channelIdx_,
                                                  config_.trigger_mode),
          "SetSampicChannelTriggerMode");
}

void SampicChannelConfigurator::setThreshold() {
    float current{};
    check(SAMPIC256CH_GetSampicChannelInternalThreshold(&params_,
                                                        boardIdx_, chipIdx_, channelIdx_,
                                                        &current),
          "GetSampicChannelInternalThreshold");

    if (current == config_.internal_threshold) {
        spdlog::trace("Channel (FEB={}, chip={}, ch={}): InternalThreshold already {} -> skip",
                      boardIdx_, chipIdx_, channelIdx_, current);
        return;
    }

    spdlog::trace("Channel (FEB={}, chip={}, ch={}): Changing InternalThreshold {} -> {}",
                  boardIdx_, chipIdx_, channelIdx_, current, config_.internal_threshold);

    check(SAMPIC256CH_SetSampicChannelInternalThreshold(&info_, &params_,
                                                        boardIdx_, chipIdx_, channelIdx_,
                                                        config_.internal_threshold),
          "SetSampicChannelInternalThreshold");
}

void SampicChannelConfigurator::setEdge() {
    EdgeType_t current{};
    check(SAMPIC256CH_GetChannelSelfTriggerEdge(&params_,
                                                boardIdx_, chipIdx_, channelIdx_,
                                                &current),
          "GetChannelSelfTriggerEdge");

    if (current == config_.trigger_edge) {
        spdlog::trace("Channel (FEB={}, chip={}, ch={}): TriggerEdge already {} -> skip",
                      boardIdx_, chipIdx_, channelIdx_, (int)current);
        return;
    }

    spdlog::trace("Channel (FEB={}, chip={}, ch={}): Changing TriggerEdge {} -> {}",
                  boardIdx_, chipIdx_, channelIdx_, (int)current, (int)config_.trigger_edge);

    check(SAMPIC256CH_SetChannelSelflTriggerEdge(&info_, &params_,
                                                 boardIdx_, chipIdx_, channelIdx_,
                                                 config_.trigger_edge),
          "SetChannelSelfTriggerEdge");
}

void SampicChannelConfigurator::setSourceForCT() {
    Boolean current{};
    check(SAMPIC256CH_GetSampicChannelSourceForCT(&params_,
                                                  boardIdx_, chipIdx_, channelIdx_,
                                                  &current),
          "GetSampicChannelSourceForCT");

    if ((bool)current == config_.enable_for_central_trigger) {
        spdlog::trace("Channel (FEB={}, chip={}, ch={}): SourceForCT already {} -> skip",
                      boardIdx_, chipIdx_, channelIdx_, (bool)current);
        return;
    }

    spdlog::trace("Channel (FEB={}, chip={}, ch={}): Changing SourceForCT {} -> {}",
                  boardIdx_, chipIdx_, channelIdx_, (bool)current,
                  config_.enable_for_central_trigger);

    check(SAMPIC256CH_SetSampicChannelSourceForCT(&info_, &params_,
                                                  boardIdx_, chipIdx_, channelIdx_,
                                                  config_.enable_for_central_trigger),
          "SetSampicChannelSourceForCT");
}

void SampicChannelConfigurator::setPulseMode() {
    Boolean current{};
    check(SAMPIC256CH_GetSampicChannelPulseMode(&params_,
                                                boardIdx_, chipIdx_, channelIdx_,
                                                &current),
          "GetSampicChannelPulseMode");

    if ((bool)current == config_.pulse_mode) {
        spdlog::trace("Channel (FEB={}, chip={}, ch={}): PulseMode already {} -> skip",
                      boardIdx_, chipIdx_, channelIdx_, (bool)current);
        return;
    }

    spdlog::trace("Channel (FEB={}, chip={}, ch={}): Changing PulseMode {} -> {}",
                  boardIdx_, chipIdx_, channelIdx_, (bool)current, config_.pulse_mode);

    check(SAMPIC256CH_SetSampicChannelPulseMode(&info_, &params_,
                                                boardIdx_, chipIdx_, channelIdx_,
                                                config_.pulse_mode),
          "SetSampicChannelPulseMode");
}

// ------------------- Utility -------------------
void SampicChannelConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error (FEB={}, chip={}, ch={}) in {} (code={})",
                      boardIdx_, chipIdx_, channelIdx_,
                      what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_chip_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_chip_configurator.cpp
Size: 20933 bytes
-----
#include "integration/sampic/config/sampic_chip_configurator.h"
#include "integration/sampic/config/sampic_channel_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>
#include <cmath>

// ------------------- Ctor -------------------
SampicChipConfigurator::SampicChipConfigurator(int boardIdx,
                                               int chipIdx,
                                               CrateInfoStruct& info,
                                               CrateParamStruct& params,
                                               SampicChipConfig& config)
    : boardIdx_(boardIdx), chipIdx_(chipIdx),
      info_(info), params_(params), config_(config) {}

// ------------------- Apply -------------------
void SampicChipConfigurator::apply() {
    spdlog::debug("Applying chip (FEB={}, chip={}) settings...", boardIdx_, chipIdx_);

    setBaseline();
    setExtThreshold();
    setExtThresholdMode();
    setTOTRange();
    setTOTFilterParams();
    setPostTrigger();
    setCentralTriggerMode();
    setCentralTriggerEffect();
    setCentralTriggerPrimitives();
    setTriggerOption();
    setEnableTriggerMode();
    setCommonDeadTime();
    setPulserWidth();
    setAdcRamp();
    setVdacDLL();
    setVdacDLLContinuity();
    setVdacRosc();
    setDllSpeedMode();
    setOverflowDac();
    setLvdsLowCurrent();

    applyChannels();

    spdlog::debug("Finished applying chip (FEB={}, chip={}).", boardIdx_, chipIdx_);
}

// ------------------- Settings -------------------

void SampicChipConfigurator::setBaseline() {
    float current{};
    check(SAMPIC256CH_GetBaselineReference(&params_, boardIdx_, chipIdx_, &current),
          "GetBaselineReference");

    if (std::fabs(current - config_.baseline_reference) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): BaselineReference already {} → skip",
                      boardIdx_, chipIdx_, current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): BaselineReference {} -> {}",
                  boardIdx_, chipIdx_, current, config_.baseline_reference);

    check(SAMPIC256CH_SetBaselineReference(&info_, &params_,
                                           boardIdx_, chipIdx_,
                                           config_.baseline_reference),
          "SetBaselineReference");
}

void SampicChipConfigurator::setExtThreshold() {
    float current{};
    check(SAMPIC256CH_GetSampicExternalThreshold(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicExternalThreshold");

    if (std::fabs(current - config_.external_threshold) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): ExternalThreshold already {} → skip",
                      boardIdx_, chipIdx_, current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): ExternalThreshold {} -> {}",
                  boardIdx_, chipIdx_, current, config_.external_threshold);

    check(SAMPIC256CH_SetSampicExternalThreshold(&info_, &params_,
                                                 boardIdx_, chipIdx_,
                                                 config_.external_threshold),
          "SetSampicExternalThreshold");
}

void SampicChipConfigurator::setExtThresholdMode() {
    Boolean current{};
    check(SAMPIC256CH_GetSampicExternalThresholdMode(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicExternalThresholdMode");

    if ((bool)current == config_.external_threshold_mode) {
        spdlog::trace("Chip (FEB={}, chip={}): ExternalThresholdMode already {} → skip",
                      boardIdx_, chipIdx_, (bool)current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): ExternalThresholdMode {} -> {}",
                  boardIdx_, chipIdx_, (bool)current, config_.external_threshold_mode);

    check(SAMPIC256CH_SetSampicExternalThresholdMode(&info_, &params_,
                                                     boardIdx_, chipIdx_,
                                                     config_.external_threshold_mode),
          "SetSampicExternalThresholdMode");
}

void SampicChipConfigurator::setTOTRange() {
    SAMPIC_TOTRange_t current{};
    check(SAMPIC256CH_GetSampicTOTRange(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicTOTRange");

    if (current == config_.tot_range) {
        spdlog::trace("Chip (FEB={}, chip={}): TOTRange already {} → skip",
                      boardIdx_, chipIdx_, int(current));
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): TOTRange {} -> {}",
                  boardIdx_, chipIdx_, int(current), int(config_.tot_range));

    check(SAMPIC256CH_SetSampicTOTRange(&info_, &params_,
                                        boardIdx_, chipIdx_,
                                        config_.tot_range),
          "SetSampicTOTRange");
}

void SampicChipConfigurator::setTOTFilterParams() {
    Boolean en{}, wide{};
    float width{};
    check(SAMPIC256CH_GetSampicTOTFilterParams(&params_, boardIdx_, chipIdx_,
                                               &en, &wide, &width),
          "GetSampicTOTFilterParams");

    if ((bool)en == config_.tot_filter_enable &&
        (bool)wide == config_.tot_wide_cap &&
        std::fabs(width - config_.tot_min_width_ns) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): TOTFilter already en={}, wide={}, width={} → skip",
                      boardIdx_, chipIdx_, (bool)en, (bool)wide, width);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): TOTFilter change to en={}, wide={}, width={}",
                  boardIdx_, chipIdx_,
                  config_.tot_filter_enable,
                  config_.tot_wide_cap,
                  config_.tot_min_width_ns);

    check(SAMPIC256CH_SetSampicTOTFilterParams(&info_, &params_,
                                               boardIdx_, chipIdx_,
                                               config_.tot_filter_enable,
                                               config_.tot_wide_cap,
                                               config_.tot_min_width_ns),
          "SetSampicTOTFilterParams");
}

void SampicChipConfigurator::setPostTrigger() {
    Boolean en{}; int val{};
    check(SAMPIC256CH_GetSampicPostTrigParams(&params_, boardIdx_, chipIdx_, &en, &val),
          "GetSampicPostTrigParams");

    if ((bool)en == config_.enable_post_trigger && val == config_.post_trigger_value) {
        spdlog::trace("Chip (FEB={}, chip={}): PostTrigger already en={}, val={} → skip",
                      boardIdx_, chipIdx_, (bool)en, val);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): PostTrigger change to en={}, val={}",
                  boardIdx_, chipIdx_,
                  config_.enable_post_trigger,
                  config_.post_trigger_value);

    check(SAMPIC256CH_SetSampicPostTrigParams(&info_, &params_,
                                              boardIdx_, chipIdx_,
                                              config_.enable_post_trigger,
                                              config_.post_trigger_value),
          "SetSampicPostTrigParams");
}

void SampicChipConfigurator::setCentralTriggerMode() {
    SampicCentralTriggerMode_t current{};
    check(SAMPIC256CH_GetSampicCentralTriggerMode(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicCentralTriggerMode");

    if (current == config_.central_trigger_mode) {
        spdlog::trace("Chip (FEB={}, chip={}): CentralTriggerMode already {} → skip",
                      boardIdx_, chipIdx_, int(current));
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): CentralTriggerMode {} -> {}",
                  boardIdx_, chipIdx_, int(current), int(config_.central_trigger_mode));

    check(SAMPIC256CH_SetSampicCentralTriggerMode(&info_, &params_,
                                                  boardIdx_, chipIdx_,
                                                  config_.central_trigger_mode),
          "SetSampicCentralTriggerMode");
}

void SampicChipConfigurator::setCentralTriggerEffect() {
    SampicCentralTriggerEffect_t current{};
    check(SAMPIC256CH_GetSampicCentralTriggerEffect(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicCentralTriggerEffect");

    if (current == config_.central_trigger_effect) {
        spdlog::trace("Chip (FEB={}, chip={}): CentralTriggerEffect already {} → skip",
                      boardIdx_, chipIdx_, int(current));
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): CentralTriggerEffect {} -> {}",
                  boardIdx_, chipIdx_, int(current), int(config_.central_trigger_effect));

    check(SAMPIC256CH_SetSampicCentralTriggerEffect(&info_, &params_,
                                                    boardIdx_, chipIdx_,
                                                    config_.central_trigger_effect),
          "SetSampicCentralTriggerEffect");
}

void SampicChipConfigurator::setCentralTriggerPrimitives() {
    SAMPIC_CT_PrimitivesMode_t mode{}; int len{};
    check(SAMPIC256CH_GetSampicCentralTriggerPrimitivesOptions(&params_, boardIdx_, chipIdx_,
                                                               &mode, &len),
          "GetSampicCentralTriggerPrimitivesOptions");

    if (mode == config_.primitives_mode && len == config_.primitives_gate_length) {
        spdlog::trace("Chip (FEB={}, chip={}): CentralTriggerPrimitives already mode={}, len={} → skip",
                      boardIdx_, chipIdx_, int(mode), len);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): CentralTriggerPrimitives change to mode={}, len={}",
                  boardIdx_, chipIdx_, int(config_.primitives_mode),
                  config_.primitives_gate_length);

    check(SAMPIC256CH_SetSampicCentralTriggerPrimitivesOptions(&info_, &params_,
                                                               boardIdx_, chipIdx_,
                                                               config_.primitives_mode,
                                                               config_.primitives_gate_length),
          "SetSampicCentralTriggerPrimitivesOptions");
}

void SampicChipConfigurator::setTriggerOption() {
    SampicTriggerOption_t current{};
    check(SAMPIC256CH_GetSampicTriggerOption(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicTriggerOption");

    if (current == config_.trigger_option) {
        spdlog::trace("Chip (FEB={}, chip={}): TriggerOption already {} → skip",
                      boardIdx_, chipIdx_, int(current));
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): TriggerOption {} -> {}",
                  boardIdx_, chipIdx_, int(current), int(config_.trigger_option));

    check(SAMPIC256CH_SetSampicTriggerOption(&info_, &params_,
                                             boardIdx_, chipIdx_,
                                             config_.trigger_option),
          "SetSampicTriggerOption");
}

void SampicChipConfigurator::setEnableTriggerMode() {
    Boolean useExt{}, openGate{}; unsigned char extGate{};
    check(SAMPIC256CH_GetSampicEnableTriggerMode(&params_, boardIdx_, chipIdx_,
                                                 &useExt, &openGate, &extGate),
          "GetSampicEnableTriggerMode");

    if ((bool)useExt == config_.enable_trigger_use_external &&
        (bool)openGate == config_.enable_trigger_open_gate_on_ext &&
        extGate == config_.enable_trigger_ext_gate) {
        spdlog::trace("Chip (FEB={}, chip={}): EnableTriggerMode already useExt={}, openGate={}, extGate={} → skip",
                      boardIdx_, chipIdx_, (bool)useExt, (bool)openGate, int(extGate));
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): EnableTriggerMode change to useExt={}, openGate={}, extGate={}",
                  boardIdx_, chipIdx_,
                  config_.enable_trigger_use_external,
                  config_.enable_trigger_open_gate_on_ext,
                  int(config_.enable_trigger_ext_gate));

    check(SAMPIC256CH_SetSampicEnableTriggerMode(&info_, &params_,
                                                 boardIdx_, chipIdx_,
                                                 config_.enable_trigger_use_external,
                                                 config_.enable_trigger_open_gate_on_ext,
                                                 config_.enable_trigger_ext_gate),
          "SetSampicEnableTriggerMode");
}

void SampicChipConfigurator::setCommonDeadTime() {
    Boolean current{};
    check(SAMPIC256CH_GetSampicCommonDeadTimeMode(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicCommonDeadTimeMode");

    if ((bool)current == config_.common_dead_time) {
        spdlog::trace("Chip (FEB={}, chip={}): CommonDeadTime already {} → skip",
                      boardIdx_, chipIdx_, (bool)current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): CommonDeadTime {} -> {}",
                  boardIdx_, chipIdx_, (bool)current, config_.common_dead_time);

    check(SAMPIC256CH_SetSampicCommonDeadTimeMode(&info_, &params_,
                                                  boardIdx_, chipIdx_,
                                                  config_.common_dead_time),
          "SetSampicCommonDeadTimeMode");
}

void SampicChipConfigurator::setPulserWidth() {
    unsigned char current{};
    check(SAMPIC256CH_GetSampicPulserWidth(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicPulserWidth");

    if (current == config_.pulser_width) {
        spdlog::trace("Chip (FEB={}, chip={}): PulserWidth already {} → skip",
                      boardIdx_, chipIdx_, int(current));
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): PulserWidth {} -> {}",
                  boardIdx_, chipIdx_, int(current), int(config_.pulser_width));

    check(SAMPIC256CH_SetSampicPulserWidth(&info_, &params_,
                                           boardIdx_, chipIdx_,
                                           config_.pulser_width),
          "SetSampicPulserWidth");
}

void SampicChipConfigurator::setAdcRamp() {
    float current{};
    check(SAMPIC256CH_GetSampicADCRampValue(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicADCRampValue");

    if (std::fabs(current - config_.adc_ramp_value) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): ADCRamp already {} → skip",
                      boardIdx_, chipIdx_, current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): ADCRamp {} -> {}",
                  boardIdx_, chipIdx_, current, config_.adc_ramp_value);

    check(SAMPIC256CH_SetSampicADCRampValue(&info_, &params_,
                                            boardIdx_, chipIdx_,
                                            config_.adc_ramp_value),
          "SetSampicADCRampValue");
}

void SampicChipConfigurator::setVdacDLL() {
    float current{};
    check(SAMPIC256CH_GetSampicVdacDLLValue(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicVdacDLLValue");

    if (std::fabs(current - config_.vdac_dll_value) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): VdacDLL already {} → skip",
                      boardIdx_, chipIdx_, current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): VdacDLL {} -> {}",
                  boardIdx_, chipIdx_, current, config_.vdac_dll_value);

    check(SAMPIC256CH_SetSampicVdacDLLValue(&info_, &params_,
                                            boardIdx_, chipIdx_,
                                            config_.vdac_dll_value),
          "SetSampicVdacDLLValue");
}

void SampicChipConfigurator::setVdacDLLContinuity() {
    float current{};
    check(SAMPIC256CH_GetSampicVdacDLLContinuity(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicVdacDLLContinuity");

    if (std::fabs(current - config_.vdac_dll_continuity) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): VdacDLLContinuity already {} → skip",
                      boardIdx_, chipIdx_, current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): VdacDLLContinuity {} -> {}",
                  boardIdx_, chipIdx_, current, config_.vdac_dll_continuity);

    check(SAMPIC256CH_SetSampicVdacDLLContinuity(&info_, &params_,
                                                 boardIdx_, chipIdx_,
                                                 config_.vdac_dll_continuity),
          "SetSampicVdacDLLContinuity");
}

void SampicChipConfigurator::setVdacRosc() {
    float current{};
    check(SAMPIC256CH_GetSampicVdacRosc(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicVdacRosc");

    if (std::fabs(current - config_.vdac_rosc) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): VdacRosc already {} → skip",
                      boardIdx_, chipIdx_, current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): VdacRosc {} -> {}",
                  boardIdx_, chipIdx_, current, config_.vdac_rosc);

    check(SAMPIC256CH_SetSampicVdacRosc(&info_, &params_,
                                        boardIdx_, chipIdx_,
                                        config_.vdac_rosc),
          "SetSampicVdacRosc");
}

void SampicChipConfigurator::setDllSpeedMode() {
    SampicDLLModeType_t current{};
    check(SAMPIC256CH_GetSampicDLLSpeedMode(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicDLLSpeedMode");

    if (current == config_.dll_speed_mode) {
        spdlog::trace("Chip (FEB={}, chip={}): DLLSpeedMode already {} → skip",
                      boardIdx_, chipIdx_, int(current));
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): DLLSpeedMode {} -> {}",
                  boardIdx_, chipIdx_, int(current), int(config_.dll_speed_mode));

    check(SAMPIC256CH_SetSampicDLLSpeedMode(&info_, &params_,
                                            boardIdx_, chipIdx_,
                                            config_.dll_speed_mode),
          "SetSampicDLLSpeedMode");
}

void SampicChipConfigurator::setOverflowDac() {
    float current{};
    check(SAMPIC256CH_GetSampicOverflowDacValue(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicOverflowDacValue");

    if (std::fabs(current - config_.overflow_dac_value) < 1e-6) {
        spdlog::trace("Chip (FEB={}, chip={}): OverflowDac already {} → skip",
                      boardIdx_, chipIdx_, current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): OverflowDac {} -> {}",
                  boardIdx_, chipIdx_, current, config_.overflow_dac_value);

    check(SAMPIC256CH_SetSampicOverflowDacValue(&info_, &params_,
                                                boardIdx_, chipIdx_,
                                                config_.overflow_dac_value),
          "SetSampicOverflowDacValue");
}

void SampicChipConfigurator::setLvdsLowCurrent() {
    Boolean current{};
    check(SAMPIC256CH_GetSampicLvdsLowCurrentMode(&params_, boardIdx_, chipIdx_, &current),
          "GetSampicLvdsLowCurrentMode");

    if ((bool)current == config_.lvds_low_current_mode) {
        spdlog::trace("Chip (FEB={}, chip={}): LvdsLowCurrent already {} → skip",
                      boardIdx_, chipIdx_, (bool)current);
        return;
    }

    spdlog::trace("Chip (FEB={}, chip={}): LvdsLowCurrent {} -> {}",
                  boardIdx_, chipIdx_, (bool)current, config_.lvds_low_current_mode);

    check(SAMPIC256CH_SetSampicLvdsLowCurrentMode(&info_, &params_,
                                                  boardIdx_, chipIdx_,
                                                  config_.lvds_low_current_mode),
          "SetSampicLvdsLowCurrentMode");
}

// ------------------- Channels descend -------------------
void SampicChipConfigurator::applyChannels() {
    spdlog::debug("Chip (FEB={}, chip={}): applying {} channels...",
                  boardIdx_, chipIdx_, config_.channels.size());
    for (auto& [chKey, chCfg] : config_.channels) {
        int chIdx = indexFromKey(chKey);
        spdlog::debug("  → Apply channel '{}' (idx={})", chKey, chIdx);
        SampicChannelConfigurator ch(boardIdx_, chipIdx_, chIdx, info_, params_, chCfg);
        ch.apply();
    }
}

// ------------------- Utility -------------------
void SampicChipConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error (FEB={}, chip={}) in {} (code={})",
                      boardIdx_, chipIdx_, what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

int SampicChipConfigurator::indexFromKey(const std::string& key) {
    size_t pos = key.find_last_not_of("0123456789");
    if (pos == std::string::npos || pos + 1 >= key.size()) {
        throw std::runtime_error("Invalid config key: " + key);
    }
    return std::stoi(key.substr(pos + 1));
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_crate_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_crate_configurator.cpp
Size: 15896 bytes
-----
#include "integration/sampic/config/sampic_crate_configurator.h"
#include "integration/sampic/config/sampic_board_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>
#include <cmath>
#include <string>

// ------------------- Ctor -------------------
SampicCrateConfigurator::SampicCrateConfigurator(CrateInfoStruct& info,
                                                 CrateParamStruct& params,
                                                 SampicSystemSettings& settings)
    : info_(info), params_(params), settings_(settings) {}

// ------------------- Apply -------------------
void SampicCrateConfigurator::apply() {
    spdlog::info("Applying SAMPIC crate settings...");

    setSamplingFrequency();
    setADCBits();
    setFramesPerBlock();
    setTOTMode();
    setSmartReadMode();

    setExternalTriggerType();
    setExternalTriggerLevel();
    setExternalTriggerEdge();
    setMinTriggersPerEvent();
    setLevel3TriggerBuild();

    setPrimitivesGateLength();
    setLevel2LatencyGateLength();
    setLevel3ExtTrigGate();
    setLevel3CoincidenceWithExtGate();

    setPulser();

    setSyncEdge();
    setSyncLevel();
    setCorrectionLevels();

    applyBoards();

    spdlog::info("SAMPIC crate settings applied.");
}

// ------------------- Acquisition -------------------
void SampicCrateConfigurator::setSamplingFrequency() {
    int current{}; Boolean useExt{};
    check(SAMPIC256CH_GetSamplingFrequency(&params_, &current, &useExt),
          "GetSamplingFrequency");

    if (current == settings_.sampling_frequency_mhz &&
        (bool)useExt == settings_.use_external_clock) {
        spdlog::trace("SamplingFrequency already {} MHz, useExt={} → skip",
                      current, (bool)useExt);
        return;
    }

    spdlog::trace("SamplingFrequency change to {} MHz, useExt={}",
                  settings_.sampling_frequency_mhz, settings_.use_external_clock);

    check(SAMPIC256CH_SetSamplingFrequency(&info_, &params_,
                                           settings_.sampling_frequency_mhz,
                                           settings_.use_external_clock),
          "SetSamplingFrequency");
}

void SampicCrateConfigurator::setFramesPerBlock() {
    int current{};
    check(SAMPIC256CH_GetNbOfFramesPerBlock(&params_, &current),
          "GetNbOfFramesPerBlock");

    if (current == settings_.frames_per_block) {
        spdlog::trace("FramesPerBlock already {} → skip", current);
        return;
    }

    spdlog::trace("FramesPerBlock {} -> {}", current, settings_.frames_per_block);

    check(SAMPIC256CH_SetNbOfFramesPerBlock(&info_, &params_, settings_.frames_per_block),
          "SetNbOfFramesPerBlock");
}

void SampicCrateConfigurator::setTOTMode() {
    Boolean current{};
    check(SAMPIC256CH_GetTOTMeasurementMode(&params_, &current),
          "GetTOTMeasurementMode");

    if ((bool)current == settings_.enable_tot) {
        spdlog::trace("TOTMode already {} → skip", (bool)current);
        return;
    }

    spdlog::trace("TOTMode {} -> {}", (bool)current, settings_.enable_tot);

    check(SAMPIC256CH_SetTOTMeasurementMode(&info_, &params_, settings_.enable_tot),
          "SetTOTMeasurementMode");
}

void SampicCrateConfigurator::setADCBits() {
    int current{};
    check(Get_SystemADCNbOfBits(&params_, &current), "Get_SystemADCNbOfBits");

    if (current == settings_.adc_bits) {
        spdlog::trace("ADC bits already {} → skip", current);
        return;
    }

    spdlog::trace("ADC bits {} -> {}", current, settings_.adc_bits);

    check(Set_SystemADCNbOfBits(&info_, &params_, settings_.adc_bits),
          "Set_SystemADCNbOfBits");
}

void SampicCrateConfigurator::setSmartReadMode() {
    Boolean mode{}; int samples{}, offset{};
    check(SAMPIC256CH_GetSmartReadMode(&params_, &mode, &samples, &offset),
          "GetSmartReadMode");

    if ((bool)mode == settings_.smart_read_mode &&
        samples == settings_.samples_to_read &&
        offset == settings_.read_offset) {
        spdlog::trace("SmartReadMode already mode={}, samples={}, offset={} → skip",
                      (bool)mode, samples, offset);
        return;
    }

    spdlog::trace("SmartReadMode change to mode={}, samples={}, offset={}",
                  settings_.smart_read_mode,
                  settings_.samples_to_read,
                  settings_.read_offset);

    check(SAMPIC256CH_SetSmartReadMode(&info_, &params_,
                                       settings_.smart_read_mode,
                                       settings_.samples_to_read,
                                       settings_.read_offset),
          "SetSmartReadMode");
}

// ------------------- External triggers -------------------
void SampicCrateConfigurator::setExternalTriggerType() {
    ExternalTriggerType_t current{};
    check(SAMPIC256CH_GetExternalTriggerType(&params_, &current),
          "GetExternalTriggerType");

    if (current == settings_.external_trigger_type) {
        spdlog::trace("ExternalTriggerType already {} → skip", int(current));
        return;
    }

    spdlog::trace("ExternalTriggerType {} -> {}", int(current),
                  int(settings_.external_trigger_type));

    check(SAMPIC256CH_SetExternalTriggerType(&info_, &params_,
                                             settings_.external_trigger_type),
          "SetExternalTriggerType");
}

void SampicCrateConfigurator::setExternalTriggerLevel() {
    SignalLevel_t current{};
    check(SAMPIC256CH_GetExternalTriggerSigLevel(&params_, &current),
          "GetExternalTriggerSigLevel");

    if (current == settings_.signal_level) {
        spdlog::trace("ExternalTriggerLevel already {} → skip", int(current));
        return;
    }

    spdlog::trace("ExternalTriggerLevel {} -> {}", int(current),
                  int(settings_.signal_level));

    check(SAMPIC256CH_SetExternalTriggerSigLevel(&info_, &params_,
                                                 settings_.signal_level),
          "SetExternalTriggerSigLevel");
}

void SampicCrateConfigurator::setExternalTriggerEdge() {
    EdgeType_t current{};
    check(SAMPIC256CH_GetExternalTriggerEdge(&params_, &current),
          "GetExternalTriggerEdge");

    if (current == settings_.trigger_edge) {
        spdlog::trace("ExternalTriggerEdge already {} → skip", int(current));
        return;
    }

    spdlog::trace("ExternalTriggerEdge {} -> {}", int(current),
                  int(settings_.trigger_edge));

    check(SAMPIC256CH_SetExternalTriggerEdge(&info_, &params_,
                                             settings_.trigger_edge),
          "SetExternalTriggerEdge");
}

void SampicCrateConfigurator::setMinTriggersPerEvent() {
    unsigned char current{};
    check(SAMPIC256CH_GetMinNbOfTriggersPerEvent(&params_, &current),
          "GetMinNbOfTriggersPerEvent");

    if (current == settings_.triggers_per_event) {
        spdlog::trace("MinTriggersPerEvent already {} → skip", int(current));
        return;
    }

    spdlog::trace("MinTriggersPerEvent {} -> {}", int(current),
                  int(settings_.triggers_per_event));

    check(SAMPIC256CH_SetMinNbOfTriggersPerEvent(&info_, &params_,
                                                 settings_.triggers_per_event),
          "SetMinNbOfTriggersPerEvent");
}

void SampicCrateConfigurator::setLevel3TriggerBuild() {
    Boolean current{};
    TriggerLogicParamStruct l3params{};  // default-initialize a real struct
    check(SAMPIC256CH_GetLevel3TriggerLogic(&params_, &current, &l3params),
          "GetLevel3TriggerLogic");

    if ((bool)current == settings_.level3_trigger_build) {
        spdlog::trace("Level3TriggerBuild already {} → skip", (bool)current);
        return;
    }

    spdlog::trace("Level3TriggerBuild {} -> {}", (bool)current,
                  settings_.level3_trigger_build);

    // Pass the struct back in for Set
    check(SAMPIC256CH_SetLevel3TriggerLogic(&info_, &params_,
                                            settings_.level3_trigger_build,
                                            l3params),
          "SetLevel3TriggerLogic");
}


// ------------------- Gates -------------------
void SampicCrateConfigurator::setPrimitivesGateLength() {
    unsigned char current{};
    check(SAMPIC256CH_GetPrimitivesGateLength(&params_, &current),
          "GetPrimitivesGateLength");

    if (current == settings_.primitives_gate_length) {
        spdlog::trace("PrimitivesGateLength already {} → skip", int(current));
        return;
    }

    spdlog::trace("PrimitivesGateLength {} -> {}",
                  int(current), int(settings_.primitives_gate_length));

    check(SAMPIC256CH_SetPrimitivesGateLength(&info_, &params_,
                                              settings_.primitives_gate_length),
          "SetPrimitivesGateLength");
}

void SampicCrateConfigurator::setLevel2LatencyGateLength() {
    unsigned char current{};
    check(SAMPIC256CH_GetLevel2LatencyGateLength(&params_, &current),
          "GetLevel2LatencyGateLength");

    if (current == settings_.latency_gate_length) {
        spdlog::trace("Level2LatencyGateLength already {} → skip", int(current));
        return;
    }

    spdlog::trace("Level2LatencyGateLength {} -> {}",
                  int(current), int(settings_.latency_gate_length));

    check(SAMPIC256CH_SetLevel2LatencyGateLength(&info_, &params_,
                                                 settings_.latency_gate_length),
          "SetLevel2LatencyGateLength");
}

void SampicCrateConfigurator::setLevel3ExtTrigGate() {
    unsigned char current{};
    check(SAMPIC256CH_GetLevel3ExtTrigGate(&params_, &current),
          "GetLevel3ExtTrigGate");

    if (current == settings_.level3_ext_trig_gate) {
        spdlog::trace("Level3ExtTrigGate already {} → skip", int(current));
        return;
    }

    spdlog::trace("Level3ExtTrigGate {} -> {}",
                  int(current), int(settings_.level3_ext_trig_gate));

    check(SAMPIC256CH_SetLevel3ExtTrigGate(&info_, &params_,
                                           settings_.level3_ext_trig_gate),
          "SetLevel3ExtTrigGate");
}

void SampicCrateConfigurator::setLevel3CoincidenceWithExtGate() {
    Boolean current{};
    check(SAMPIC256CH_GetLevel3CoincidenceModeWithExtTrigGate(&params_, &current),
          "GetLevel3CoincidenceModeWithExtTrigGate");

    if ((bool)current == settings_.level3_coincidence_ext_gate) {
        spdlog::trace("Level3CoincidenceWithExtGate already {} → skip", (bool)current);
        return;
    }

    spdlog::trace("Level3CoincidenceWithExtGate {} -> {}", (bool)current,
                  settings_.level3_coincidence_ext_gate);

    check(SAMPIC256CH_SetLevel3CoincidenceModeWithExtTrigGate(&info_, &params_,
                                                              settings_.level3_coincidence_ext_gate),
          "SetLevel3CoincidenceModeWithExtTrigGate");
}

// ------------------- Pulser -------------------
void SampicCrateConfigurator::setPulser() {
    Boolean en{}; PulserSourceType_t src{}; Boolean sync{}; int period{};
    check(SAMPIC256CH_GetPulserMode(&params_, &en, &src, &sync),
          "GetPulserMode");

    check(SAMPIC256CH_GetAutoPulserPeriod(&params_, &period),
          "GetAutoPulserPeriod");

    if ((bool)en == settings_.pulser_enable &&
        src == settings_.pulser_source &&
        (bool)sync == settings_.pulser_synchronous &&
        period == settings_.pulser_period) {
        spdlog::trace("Pulser already en={}, src={}, sync={}, period={} → skip",
                      (bool)en, int(src), (bool)sync, period);
        return;
    }

    spdlog::trace("Pulser change to en={}, src={}, sync={}, period={}",
                  settings_.pulser_enable,
                  int(settings_.pulser_source),
                  settings_.pulser_synchronous,
                  settings_.pulser_period);

    check(SAMPIC256CH_SetPulserMode(&info_, &params_,
                                    settings_.pulser_enable,
                                    settings_.pulser_source,
                                    settings_.pulser_synchronous),
          "SetPulserMode");

    check(SAMPIC256CH_SetAutoPulserPeriod(&info_, &params_,
                                          settings_.pulser_period),
          "SetAutoPulserPeriod");
}

// ------------------- Sync + corrections -------------------
void SampicCrateConfigurator::setSyncEdge() {
    EdgeType_t current{};
    check(SAMPIC256CH_GetExternalSyncEdge(&params_, &current),
          "GetExternalSyncEdge");

    if (current == settings_.sync_edge) {
        spdlog::trace("SyncEdge already {} → skip", int(current));
        return;
    }

    spdlog::trace("SyncEdge {} -> {}", int(current), int(settings_.sync_edge));

    check(SAMPIC256CH_SetExternalSyncEdge(&info_, &params_, settings_.sync_edge),
          "SetExternalSyncEdge");
}

void SampicCrateConfigurator::setSyncLevel() {
    SignalLevel_t current{};
    check(SAMPIC256CH_GetExternalSyncSigLevel(&params_, &current),
          "GetExternalSyncSigLevel");

    if (current == settings_.sync_level) {
        spdlog::trace("SyncLevel already {} → skip", int(current));
        return;
    }

    spdlog::trace("SyncLevel {} -> {}", int(current), int(settings_.sync_level));

    check(SAMPIC256CH_SetExternalSyncSigLevel(&info_, &params_, settings_.sync_level),
          "SetExternalSyncSigLevel");
}

void SampicCrateConfigurator::setCorrectionLevels() {
    Boolean adc{}, inl{}, ped{};
    check(SAMPIC256CH_GetCrateCorrectionLevels(&info_, &params_, &adc, &inl, &ped),
          "GetCrateCorrectionLevels");

    if ((bool)adc == settings_.adc_linearity_correction &&
        (bool)inl == settings_.time_inl_correction &&
        (bool)ped == settings_.residual_pedestal_correction) {
        spdlog::trace("CorrectionLevels already adc={}, inl={}, ped={} → skip",
                      (bool)adc, (bool)inl, (bool)ped);
        return;
    }

    spdlog::trace("CorrectionLevels change to adc={}, inl={}, ped={}",
                  settings_.adc_linearity_correction,
                  settings_.time_inl_correction,
                  settings_.residual_pedestal_correction);

    check(SAMPIC256CH_SetCrateCorrectionLevels(&info_, &params_,
                                               settings_.adc_linearity_correction,
                                               settings_.time_inl_correction,
                                               settings_.residual_pedestal_correction),
          "SetCrateCorrectionLevels");
}

// ------------------- Boards descend -------------------
void SampicCrateConfigurator::applyBoards() {
    spdlog::debug("Applying front-end boards...");
    for (auto& [key, febCfg] : settings_.front_end_boards) {
        int febIdx = indexFromKey(key);

        if (!febCfg.enabled) {
            spdlog::info("Skipping FEB '{}' (index={}) — disabled.", key, febIdx);
            continue;
        }

        spdlog::debug("Apply FEB '{}'(index={})", key, febIdx);
        SampicBoardConfigurator feb(febIdx, info_, params_, febCfg);
        feb.apply();
    }
    spdlog::debug("Front-end boards applied.");
}

// ------------------- Utility -------------------
void SampicCrateConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error in {} (code={})", what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

int SampicCrateConfigurator::indexFromKey(const std::string& key) {
    size_t pos = key.find_last_not_of("0123456789");
    if (pos == std::string::npos || pos + 1 >= key.size()) {
        throw std::runtime_error("Invalid config key: " + key);
    }
    return std::stoi(key.substr(pos + 1));
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.cpp
Size: 737 bytes
-----
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h"
#include "integration/sampic/config/sampic_crate_configurator.h"
#include <spdlog/spdlog.h>

void SampicApplySettingsModeDefault::apply() {
    spdlog::info("ApplySettingsModeDefault: Applying full crate configuration...");

    try {
        // Use the configurator to apply *everything* from settings_
        SampicCrateConfigurator crateCfg(info_, params_, settings_);
        crateCfg.apply();

        spdlog::info("ApplySettingsModeDefault: All settings applied successfully.");
    } catch (const std::exception& e) {
        spdlog::error("ApplySettingsModeDefault: Exception during apply: {}", e.what());
        throw;
    }
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.cpp
Size: 2592 bytes
-----
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h"
#include "integration/sampic/config/sampic_crate_configurator.h"
#include "integration/sampic/config/sampic_board_configurator.h"
#include "integration/sampic/config/sampic_chip_configurator.h"
#include "integration/sampic/config/sampic_channel_configurator.h"
#include <spdlog/spdlog.h>

void SampicApplySettingsModeExample::apply() {
    spdlog::info("ApplySettingsModeExample: Setting trigger options...");

    try {
        // --- Crate-level ---
        SampicCrateConfigurator crateCfg(info_, params_, settings_);
        crateCfg.setExternalTriggerType();

        // --- Loop over boards / chips / channels ---
        for (auto& [boardKey, boardCfg] : settings_.front_end_boards) {
            if (!boardCfg.enabled) {
                spdlog::debug("Skipping disabled board '{}'", boardKey);
                continue;
            }

            int boardIdx = crateCfg.indexFromKey(boardKey);
            SampicBoardConfigurator boardConfigurator(boardIdx, info_, params_, boardCfg);

            for (auto& [chipKey, chipCfg] : boardCfg.sampics) {
                if (!chipCfg.enabled) {
                    spdlog::debug("Skipping disabled chip '{}:{}'", boardKey, chipKey);
                    continue;
                }

                int chipIdx = boardConfigurator.indexFromKey(chipKey);
                SampicChipConfigurator chipConfigurator(boardIdx, chipIdx, info_, params_, chipCfg);

                // SAMPIC_TRIGGER_IS_L1
                chipConfigurator.setTriggerOption();

                for (auto& [chKey, chCfg] : chipCfg.channels) {
                    if (!chCfg.enabled) {
                        spdlog::trace("Skipping disabled channel '{}:{}:{}'",
                                      boardKey, chipKey, chKey);
                        continue;
                    }

                    int chIdx = chipConfigurator.indexFromKey(chKey);
                    SampicChannelConfigurator chConfigurator(boardIdx, chipIdx, chIdx,
                                                             info_, params_, chCfg);

                    // Enable channel + set EXT_TRIGGER_MODE
                    chConfigurator.setMode();
                    chConfigurator.setTriggerMode();
                }
            }
        }

        spdlog::info("ApplySettingsModeExample: Trigger options set successfully.");

    } catch (const std::exception& e) {
        spdlog::error("ApplySettingsModeExample: Exception during apply: {}", e.what());
        throw;
    }
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.cpp
Size: 1893 bytes
-----
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h"
#include <spdlog/spdlog.h>
#include <cstring>

int SampicInitSettingsModeDefault::initialize() {
    spdlog::info("InitSettingsModeDefault: Initializing SAMPIC system...");

    CrateConnectionParamStruct conn{};
    conn.ConnectionType = settings_.connection_type;
    conn.ControlBoardControlType = settings_.control_type;
    strncpy(conn.CtrlIpAddress, settings_.ip_address.c_str(), sizeof(conn.CtrlIpAddress) - 1);
    conn.CtrlIpAddress[sizeof(conn.CtrlIpAddress) - 1] = '\0';
    conn.CtrlPort = settings_.port;

    auto err = SAMPIC256CH_OpenCrateConnection(conn, &info_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeDefault: Failed to open crate connection (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeDefault: Connection opened with {} FE boards.", info_.NbOfFeBoards);

    err = SAMPIC256CH_SetDefaultParameters(&info_, &params_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeDefault: Failed to open crate connection (err={})", static_cast<int>(err));
        return err;
    }

    err = SAMPIC256CH_LoadAllCalibValuesFromFiles(&info_, &params_,
                                                  const_cast<char*>(settings_.calibration_directory.c_str()));
    if (err != SAMPIC256CH_Success) {
        spdlog::warn("InitSettingsModeDefault: Calibration files missing, continuing anyway...");
    }

    err = SAMPIC256CH_AllocateEventMemory(&eventBuffer_, &mlFrames_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeDefault: Failed to allocate event memory (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeDefault: Event memory allocated successfully.");

    return SAMPIC256CH_Success;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.cpp
Size: 1894 bytes
-----
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h"
#include <spdlog/spdlog.h>
#include <cstring>

int SampicInitSettingsModeExample::initialize() {
    spdlog::info("InitSettingsModeExample: Initializing SAMPIC system...");

    CrateConnectionParamStruct conn{};
    conn.ConnectionType = settings_.connection_type;
    conn.ControlBoardControlType = settings_.control_type;
    strncpy(conn.CtrlIpAddress, settings_.ip_address.c_str(), sizeof(conn.CtrlIpAddress) - 1);
    conn.CtrlIpAddress[sizeof(conn.CtrlIpAddress) - 1] = '\0';
    conn.CtrlPort = settings_.port;

    auto err = SAMPIC256CH_OpenCrateConnection(conn, &info_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeExample: Failed to open crate connection (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeExample: Connection opened with {} FE boards.", info_.NbOfFeBoards);

    err = SAMPIC256CH_SetDefaultParameters(&info_, &params_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeExample: Failed to set default parameters (err={})", static_cast<int>(err));
        return err;
    }

    err = SAMPIC256CH_LoadAllCalibValuesFromFiles(&info_, &params_,
                                                  const_cast<char*>(settings_.calibration_directory.c_str()));
    if (err != SAMPIC256CH_Success) {
        spdlog::warn("InitSettingsModeExample: Calibration files missing, continuing anyway...");
    }

    err = SAMPIC256CH_AllocateEventMemory(&eventBuffer_, &mlFrames_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeExample: Failed to allocate event memory (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeExample: Event memory allocated successfully.");

    return SAMPIC256CH_Success;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/sampic_controller.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/sampic_controller.cpp
Size: 5825 bytes
-----
#include "integration/sampic/controller/sampic_controller.h"
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h"
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h"
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h"
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h"

SampicController::SampicController(const SampicSystemSettings& sys_cfg,
                                   const SampicControllerConfig& ctrl_cfg,
                                   const SampicCollectorConfig& coll_cfg)
    : settings_(sys_cfg),
      ctrl_cfg_(ctrl_cfg),
      coll_cfg_(coll_cfg)
{
    // Select init mode
    switch (ctrl_cfg_.init_mode) {
        case SampicInitSettingsModeType::DEFAULT:
            init_mode_ = std::make_unique<SampicInitSettingsModeDefault>(
                info_, params_, eventBuffer_, mlFrames_, settings_, ctrl_cfg_);
            break;
        case SampicInitSettingsModeType::EXAMPLE:
            init_mode_ = std::make_unique<SampicInitSettingsModeExample>(
                info_, params_, eventBuffer_, mlFrames_, settings_, ctrl_cfg_);
            break;
    }

    // Select apply mode
    switch (ctrl_cfg_.apply_mode) {
        case SampicApplySettingsModeType::DEFAULT:
            apply_mode_ = std::make_unique<SampicApplySettingsModeDefault>(
                info_, params_, settings_, ctrl_cfg_);
            break;
        case SampicApplySettingsModeType::EXAMPLE:
            apply_mode_ = std::make_unique<SampicApplySettingsModeExample>(
                info_, params_, settings_, ctrl_cfg_);
            break;
    }

    // Create collector (owns its buffer)
    collector_ = std::make_unique<SampicCollector>(
        coll_cfg_, info_, params_, eventBuffer_, mlFrames_);
}

SampicController::~SampicController() {
    try {
        stopCollector();
        stopRun();
        cleanup();
    } catch (...) {
        // swallow errors in destructor
    }
}

// ---------------- Config management ----------------
void SampicController::setSystemSettings(const SampicSystemSettings& s) { settings_ = s; }
SampicSystemSettings& SampicController::systemSettings() { return settings_; }
const SampicSystemSettings& SampicController::systemSettings() const { return settings_; }

void SampicController::setControllerConfig(const SampicControllerConfig& c) { ctrl_cfg_ = c; }
SampicControllerConfig& SampicController::controllerConfig() { return ctrl_cfg_; }
const SampicControllerConfig& SampicController::controllerConfig() const { return ctrl_cfg_; }

void SampicController::setCollectorConfig(const SampicCollectorConfig& c) { coll_cfg_ = c; }
SampicCollectorConfig& SampicController::collectorConfig() { return coll_cfg_; }
const SampicCollectorConfig& SampicController::collectorConfig() const { return coll_cfg_; }

// ---------------- Lifecycle ----------------
int SampicController::initialize() {
    if (!init_mode_) {
        spdlog::error("Init mode not configured");
        return -1;
    }
    int rc = init_mode_->initialize();
    initialized_ = (rc == SAMPIC256CH_Success);
    return rc;
}

int SampicController::applySettings() {
    if (!apply_mode_) {
        spdlog::error("Apply mode not configured");
        return -1;
    }
    try {
        // Apply hardware settings
        apply_mode_->apply();

        // Rebuild collector with updated config
        stopCollector();
        collector_.reset();
        collector_ = std::make_unique<SampicCollector>(
            coll_cfg_, info_, params_, eventBuffer_, mlFrames_);

        spdlog::info("Collector rebuilt with new configuration");
        return 0;
    } catch (const std::exception& e) {
        spdlog::error("Apply settings failed: {}", e.what());
        return -1;
    }
}

int SampicController::startRun() {
    if (run_started_) {
        spdlog::warn("startRun() called but run already started");
        return 0;
    }

    spdlog::info("Starting SAMPIC run...");
    auto err = SAMPIC256CH_StartRun(&info_, &params_, TRUE);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("Failed to start run (err={})", static_cast<int>(err));
        return err;
    }
    run_started_ = true;
    return 0;
}

int SampicController::stopRun() {
    if (!run_started_) {
        spdlog::debug("stopRun() called but run was not started — skipping");
        return 0;
    }

    spdlog::info("Stopping SAMPIC run...");
    auto err = SAMPIC256CH_StopRun(&info_, &params_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("Failed to stop run (err={})", static_cast<int>(err));
        return err;
    }
    run_started_ = false;
    return 0;
}

void SampicController::cleanup() {
    if (!initialized_) {
        spdlog::debug("cleanup() called but controller not initialized — skipping");
        return;
    }

    spdlog::info("Cleaning up SAMPIC resources...");
    if (eventBuffer_ || mlFrames_) {
        SAMPIC256CH_FreeEventMemory(&eventBuffer_, &mlFrames_);
        eventBuffer_ = nullptr;
        mlFrames_ = nullptr;
    }
    SAMPIC256CH_CloseCrateConnection(&info_);
    initialized_ = false;
}

// ---------------- Collector ----------------
void SampicController::startCollector() {
    if (collector_ && !collector_running_) {
        collector_->start();
        collector_running_ = true;
    }
}
void SampicController::stopCollector() {
    if (collector_ && collector_running_) {
        collector_->stop();
        collector_running_ = false;
    }
}

// ---------------- Buffer access ----------------
SampicEventBuffer& SampicController::buffer() {
    return collector_->buffer();
}
const SampicEventBuffer& SampicController::buffer() const {
    return collector_->buffer();
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/splog/logger_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/splog/logger_configurator.cpp
Size: 1241 bytes
-----
#include "integration/spdlog/logger_configurator.h"

#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/spdlog.h>

void LoggerConfigurator::configure(const LoggerConfig& cfg) {
    std::vector<spdlog::sink_ptr> sinks;

    if (cfg.to_console) {
        sinks.push_back(std::make_shared<spdlog::sinks::stdout_color_sink_mt>());
    }

    if (cfg.to_file) {
        sinks.push_back(std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
            cfg.log_file, cfg.max_file_size, cfg.max_files));
    }

    if (sinks.empty()) {
        // fallback to console if nothing is selected
        sinks.push_back(std::make_shared<spdlog::sinks::stdout_color_sink_mt>());
    }

    auto logger = std::make_shared<spdlog::logger>(cfg.name, sinks.begin(), sinks.end());

    // Apply pattern and level
    logger->set_pattern(cfg.log_pattern);
    auto level = spdlog::level::from_str(cfg.log_level);
    logger->set_level(level);
    logger->flush_on(spdlog::level::err);

    // Install as global default logger
    spdlog::set_default_logger(logger);
    spdlog::set_level(level); // global filter level

    spdlog::info("Logger '{}' initialized at level {}", cfg.name, cfg.log_level);
}
===== FILE END =====

===== FILE START =====
Relative Path: src/processing/sampic_processing/collector/frontend_event_buffer.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/processing/sampic_processing/collector/frontend_event_buffer.cpp
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: src/processing/sampic_processing/collector/frontend_event_collector.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/processing/sampic_processing/collector/frontend_event_collector.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: src/processing/sampic_processing/config/frontend_event_collector_config.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/processing/sampic_processing/config/frontend_event_collector_config.cpp
Size: 0 bytes
-----

===== FILE END =====

