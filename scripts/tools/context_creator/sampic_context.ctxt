===== FILE START =====
Relative Path: frontend.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/frontend.cpp
Size: 15015 bytes
-----
// ======================================================================
// SAMPIC Frontend (buffer-based, ODB-driven; controller owns collector)
// ======================================================================

// System
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <chrono>
#include <thread>
#include <mutex>
#include <memory>
#include <optional>
#include <string>
#include <unistd.h>

// MIDAS
#include "midas.h"
#include "mfe.h"

// Project: ODB + logging + FE config
#include "integration/midas/frontend_config.h"
#include "integration/midas/odb/odb_manager.h"
#include "integration/midas/odb/odb_utils.h"
#include "integration/spdlog/logger_config.h"
#include "integration/spdlog/logger_configurator.h"

// Project: SAMPIC configs + controller
#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_controller_config.h"
#include "integration/sampic/config/sampic_collector_config.h"
#include "integration/sampic/controller/sampic_controller.h"

// Event + timing structs
#include "integration/sampic/collector/sampic_event_buffer.h"

// ======================================================================
// Compact bank payloads
// ======================================================================
#pragma pack(push, 1)
struct SampicEventLite {
  uint32_t nb_hits;
  uint32_t nb_triggers;
};

// No fixed samples[] here — we write samples right after this meta.
struct SampicHitMeta {
  int32_t fe_board;
  int32_t sampic_idx;
  int32_t channel;
  int32_t hit_number;

  // number of samples that follow (uint16_t each)
  int32_t data_size;

  float   amplitude;
  float   baseline;
  float   peak;
  double  time_ns;
};
#pragma pack(pop)

// ======================================================================
// Globals (MIDAS)
// ======================================================================
const char *frontend_name       = "SAMPIC_Frontend";
const char *frontend_file_name  = __FILE__;
BOOL        frontend_call_loop  = FALSE;
INT         display_period      = 0;
INT         max_event_size      = 128 * 1024 * 1024;
INT         max_event_size_frag = 5 * max_event_size;
INT         event_buffer_size   = 5 * max_event_size;

static INT  g_frontend_index     = 0;
static char g_settings_path[256] = {0};

static bool g_system_initialized = false;

// Polling
static std::chrono::steady_clock::time_point g_last_poll_time;
static std::chrono::microseconds             g_polling_interval(1'000'000); // default 1s
static std::chrono::steady_clock::time_point g_last_evt_ts = std::chrono::steady_clock::time_point::min();

// Configs read from ODB
static FrontendConfig         g_fe_cfg;
static LoggerConfig           g_logger_cfg;
static SampicSystemSettings   g_sys_cfg;
static SampicControllerConfig g_ctrl_cfg;
static SampicCollectorConfig  g_coll_cfg;

// Controller (owns collector + buffer)
static std::unique_ptr<SampicController> g_controller;

// ======================================================================
// Prototypes
// ======================================================================
INT frontend_init(void);
INT frontend_exit(void);
INT begin_of_run(INT run_number, char *error);
INT end_of_run(INT run_number, char *error);
INT pause_run(INT run_number, char *error);
INT resume_run(INT run_number, char *error);
INT frontend_loop(void);

INT read_sampic_event(char *pevent, INT off);
INT poll_event(INT source, INT count, BOOL test);
INT interrupt_configure(INT cmd, INT source, POINTER_T adr);

// ======================================================================
// Equipment
// ======================================================================
BOOL equipment_common_overwrite = TRUE;

EQUIPMENT equipment[] = {
    {"SAMPIC %02d",
        { 1, 0,
          "SYSTEM",
          EQ_POLLED | EQ_EB,
          0,
          "MIDAS",
          TRUE,
          RO_RUNNING,
          100,
          0,
          0,
          TRUE,
          "", "", "", },
        read_sampic_event
    },
    {""}
};

// ======================================================================
// Utilities
// ======================================================================
static std::string make_bank_name(const std::string& prefix, int idx2d) {
  std::string p = prefix.empty() ? "XX" : prefix.substr(0,2);
  char name[8];
  std::snprintf(name, sizeof(name), "%s%02d", p.c_str(), idx2d);
  return std::string(name);
}

// ======================================================================
// ODB helpers
// ======================================================================
static bool initialize_all_configs_from_odb(std::string& err_out) {
  try {
    OdbManager odb;
    const std::string base = g_settings_path;

    odb.initialize(base + "/Logger", LoggerConfig{});
    g_logger_cfg = odb.read<LoggerConfig>(base + "/Logger");
    LoggerConfigurator::configure(g_logger_cfg);

    odb.initialize(base + "/Frontend", FrontendConfig{});
    g_fe_cfg = odb.read<FrontendConfig>(base + "/Frontend");

    odb.initialize(base + "/Crate", SampicSystemSettings{});
    g_sys_cfg = odb.read<SampicSystemSettings>(base + "/Crate");

    odb.initialize(base + "/Sampic Controller", SampicControllerConfig{});
    g_ctrl_cfg = odb.read<SampicControllerConfig>(base + "/Sampic Controller");

    odb.initialize(base + "/Sampic Event Collector", SampicCollectorConfig{});
    g_coll_cfg = odb.read<SampicCollectorConfig>(base + "/Sampic Event Collector");

    g_polling_interval = std::chrono::microseconds(g_fe_cfg.polling_interval_us);
    return true;
  } catch (const std::exception& e) {
    err_out = e.what();
    return false;
  }
}

static bool read_all_configs_from_odb(std::string& err_out) {
  try {
    OdbManager odb;
    const std::string base = g_settings_path;

    g_logger_cfg = odb.read<LoggerConfig>(base + "/Logger");
    g_fe_cfg     = odb.read<FrontendConfig>(base + "/Frontend");
    g_sys_cfg    = odb.read<SampicSystemSettings>(base + "/Crate");
    g_ctrl_cfg   = odb.read<SampicControllerConfig>(base + "/Sampic Controller");
    g_coll_cfg   = odb.read<SampicCollectorConfig>(base + "/Sampic Event Collector");

    LoggerConfigurator::configure(g_logger_cfg);
    g_polling_interval = std::chrono::microseconds(g_fe_cfg.polling_interval_us);
    return true;
  } catch (const std::exception& e) {
    err_out = e.what();
    return false;
  }
}

// ======================================================================
// SAMPIC controller setup
// ======================================================================
static bool initialize_sampic_controller(std::string& err_out) {
  try {
    g_controller = std::make_unique<SampicController>(g_sys_cfg, g_ctrl_cfg, g_coll_cfg);

    int rc = g_controller->initialize();
    if (rc != 0) {
      err_out = "SAMPIC controller initialize() failed with code " + std::to_string(rc);
      return false;
    }
    return true;
  } catch (const std::exception& e) {
    err_out = e.what();
    return false;
  }
}

// ======================================================================
// MIDAS Frontend impl
// ======================================================================
INT frontend_init() {
  g_frontend_index = get_frontend_index();
  std::snprintf(g_settings_path, sizeof(g_settings_path),
                "/Equipment/SAMPIC %02d/Settings", g_frontend_index);

  OdbUtils::odbSetStatusColor(g_frontend_index, g_fe_cfg.init_color);

  std::string err;
  if (!initialize_all_configs_from_odb(err)) {
    cm_msg(MERROR, __FUNCTION__, "Failed to initialize configs: %s", err.c_str());
    return FE_ERR_ODB;
  }
  if (!initialize_sampic_controller(err)) {
    cm_msg(MERROR, __FUNCTION__, "Failed to init controller: %s", err.c_str());
    return FE_ERR_HW;
  }

  g_system_initialized = true;
  OdbUtils::odbSetStatusColor(g_frontend_index, g_fe_cfg.ready_color);
  return SUCCESS;
}

INT frontend_exit() {
  try {
    if (g_controller) {
      g_controller->stopCollector();
      g_controller->stopRun();
      g_controller->cleanup();
    }
  } catch (...) {}
  g_controller.reset();
  g_system_initialized = false;
  return SUCCESS;
}

INT begin_of_run(INT run_number, char *error) {
  if (!g_system_initialized || !g_controller) {
    std::strcpy(error, "System not initialized");
    return FE_ERR_HW;
  }

  std::string err;
  if (!read_all_configs_from_odb(err)) {
    std::snprintf(error, 256, "Failed to refresh configs: %s", err.c_str());
    return FE_ERR_ODB;
  }

  g_controller->setSystemSettings(g_sys_cfg);
  g_controller->setControllerConfig(g_ctrl_cfg);
  g_controller->setCollectorConfig(g_coll_cfg);

  if (g_controller->applySettings() != 0) {
    std::strcpy(error, "Failed to apply settings");
    return FE_ERR_HW;
  }

  g_controller->startCollector();
  if (g_controller->startRun() != 0) {
    std::strcpy(error, "Failed to start run");
    return FE_ERR_HW;
  }

  g_last_evt_ts = std::chrono::steady_clock::time_point::min();
  return SUCCESS;
}

INT end_of_run(INT, char *error) {
  try {
    if (g_controller) {
      g_controller->stopCollector();
      if (g_controller->stopRun() != 0) {
        std::strcpy(error, "Failed to stop run");
        return FE_ERR_HW;
      }
    }
  } catch (...) {
    std::strcpy(error, "Error during EOR");
    return FE_ERR_HW;
  }
  return SUCCESS;
}

INT pause_run(INT, char*)  { return SUCCESS; }
INT resume_run(INT, char*) { return SUCCESS; }
INT frontend_loop()        { return SUCCESS; }

// ======================================================================
// Polling
// ======================================================================
INT poll_event(INT, INT, BOOL test) {
  if (!g_system_initialized || !g_controller) return test ? FALSE : 0;

  auto now = std::chrono::steady_clock::now();
  if (now - g_last_poll_time < g_polling_interval) return test ? FALSE : 0;
  g_last_poll_time = now;

  if (g_controller->buffer().hasNewSince(g_last_evt_ts)) return TRUE;
  return test ? FALSE : 0;
}

INT interrupt_configure(INT, INT, POINTER_T) { return SUCCESS; }

// ======================================================================
// Readout (full-waveform, variable-length hits; one ADxx + one ATxx)
// ======================================================================
INT read_sampic_event(char *pevent, INT) {
  if (!g_system_initialized || !g_controller) {
    spdlog::warn("read_sampic_event: system not initialized, skipping");
    return 0;
  }

  const auto new_events = g_controller->buffer().getSince(g_last_evt_ts);
  if (new_events.empty()) {
    spdlog::debug("read_sampic_event: no new events since last timestamp");
    return 0;
  }

  // Init MIDAS event container
  bk_init32(pevent);

  // ------------------------- DATA BANK (ADxx) -------------------------
  {
    const auto data_bank = make_bank_name(g_fe_cfg.data_bank_prefix, g_frontend_index);
    uint8_t* pdata = nullptr;
    bk_create(pevent, data_bank.c_str(), TID_UINT8, (void**)&pdata);
    uint8_t* const pdata_start = pdata;

    // Pack each collected SAMPIC event in sequence
    for (size_t iev = 0; iev < new_events.size(); ++iev) {
      const auto& tse = new_events[iev];
      if (!tse.event) {
        spdlog::warn("read_sampic_event: event {} has null pointer, skipping", iev);
        continue;
      }
      const auto ev = tse.event;

      // --- Event header ---
      const SampicEventLite evhdr{
        static_cast<uint32_t>(ev->NbOfHitsInEvent),
        static_cast<uint32_t>(ev->TriggerData.NbOfTriggers)
      };
      std::memcpy(pdata, &evhdr, sizeof(evhdr));
      pdata += sizeof(evhdr);

      spdlog::debug("Packing event {} → hits={}, triggers={}",
                    iev, evhdr.nb_hits, evhdr.nb_triggers);

      // --- Hits (variable-length) ---
      for (int i = 0; i < ev->NbOfHitsInEvent; ++i) {
        const auto& h = ev->Hit[i];

        // Choose a sane clamp to avoid corrupt banks if upstream is wrong
        // (tweak if you know chip max samples; 4096 is conservative)
        constexpr int kMaxSafeSamples = 4096;
        int data_size = std::max(0, std::min(h.DataSize, kMaxSafeSamples));

        SampicHitMeta meta{};
        meta.fe_board   = h.FeBoardIndex;
        meta.sampic_idx = h.SampicIndex;
        meta.channel    = h.Channel;
        meta.hit_number = h.HitNumber;
        meta.data_size  = data_size;
        meta.amplitude  = h.Amplitude;
        meta.baseline   = h.Baseline;
        meta.peak       = h.Peak;
        meta.time_ns    = h.TimeInstant;

        // Write meta
        std::memcpy(pdata, &meta, sizeof(meta));
        pdata += sizeof(meta);

        // Write all samples (uint16_t)
        const size_t bytes_samples = static_cast<size_t>(data_size) * sizeof(uint16_t);
        if (data_size > 0) {
          std::memcpy(pdata, h.OrderedRawDataSamples, bytes_samples);
          pdata += bytes_samples;
        }

        spdlog::trace("  hit {}: board={}, sampic={}, ch={}, hit#={}, nsamp={}, "
                      "amp={:.2f}, base={:.2f}, peak={:.2f}, t={:.3f} ns "
                      "(wrote {} + {} bytes)",
                      i, meta.fe_board, meta.sampic_idx, meta.channel, meta.hit_number,
                      meta.data_size, meta.amplitude, meta.baseline, meta.peak, meta.time_ns,
                      (int)sizeof(meta), (int)bytes_samples);
      }
    }

    bk_close(pevent, pdata);
    spdlog::debug("Closed data bank {} ({} bytes)", data_bank, (int)(pdata - pdata_start));
  }

  // ------------------------ TIMING BANK (ATxx) ------------------------
  {
    const auto timing_bank = make_bank_name(g_fe_cfg.timing_bank_prefix, g_frontend_index);
    uint8_t* ptiming = nullptr;
    bk_create(pevent, timing_bank.c_str(), TID_UINT8, (void**)&ptiming);
    uint8_t* const ptiming_start = ptiming;

    struct TimingPayload {
      uint64_t timestamp_ns;
      uint32_t prepare_us, read_us, decode_us, total_us;
    };

    for (const auto& tse : new_events) {
      TimingPayload tp;
      tp.timestamp_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                          tse.timestamp.time_since_epoch()).count();
      tp.prepare_us   = tse.timing.prepare_duration.count();
      tp.read_us      = tse.timing.read_duration.count();
      tp.decode_us    = tse.timing.decode_duration.count();
      tp.total_us     = tse.timing.total_duration.count();

      std::memcpy(ptiming, &tp, sizeof(tp));
      ptiming += sizeof(tp);

      spdlog::trace("  timing: ts={} ns, prep={}us, read={}us, dec={}us, total={}us",
                    tp.timestamp_ns, tp.prepare_us, tp.read_us, tp.decode_us, tp.total_us);
    }

    bk_close(pevent, ptiming);
    spdlog::debug("Closed timing bank {} ({} bytes)", timing_bank, (int)(ptiming - ptiming_start));
  }

  // Advance watermark
  g_last_evt_ts = new_events.back().timestamp;

  const int total_size = bk_size(pevent);
  spdlog::debug("read_sampic_event: MIDAS event size {}", total_size);
  return total_size;
}

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/midas/frontend_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/midas/frontend_config.h
Size: 780 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_MIDAS_FRONTEND_CONFIG_H
#define SAMPIC_DAQ_INTEGRATION_MIDAS_FRONTEND_CONFIG_H

#include <string>
#include <cstddef>

// Configuration for MIDAS frontend integration.
// These parameters can be populated from the ODB.
struct FrontendConfig {
    size_t min_bytes_to_trigger_on = 0;   // minimum event size in bytes
    std::string init_color = "#8A2BE2";      // initial color code for frontend GUI
    std::string ready_color = "greenLight";  // ready status color
    int polling_interval_us = 1000;          // polling interval (microseconds)
    std::string data_bank_prefix = "AD";     // prefix for data banks
    std::string timing_bank_prefix = "AT";   // prefix for timing banks
};

#endif // SAMPIC_DAQ_INTEGRATION_MIDAS_FRONTEND_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/midas/odb/odb_manager.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/midas/odb/odb_manager.h
Size: 1866 bytes
-----
#ifndef ODB_MANAGER_H
#define ODB_MANAGER_H

#include "midas.h"
#include <nlohmann/json.hpp>
#include <rfl/json.hpp>
#include <spdlog/spdlog.h>

#include <string>
#include <vector>
#include <optional>
#include <stdexcept>

using json = nlohmann::json;

extern HNDLE hDB;

class OdbManager {
public:
    explicit OdbManager(HNDLE handle = hDB) : hDB_handle(handle) {}

    // JSON/String API
    std::string read(const std::string& path);
    json read(const std::string& path, bool return_json_object);

    void write(const std::string& path, const std::string& jsonStr);
    void write(const std::string& path, const json& j);

    void initialize(const std::string& path, const std::string& jsonStr);
    void initialize(const std::string& path, const json& j);

    // Generic template API (Reflect-C++)
    template <typename T>
    T read(const std::string& path) {
        std::string jsonStr = read(path);

        auto parsed = rfl::json::read<T>(jsonStr);
        if (!parsed.has_value()) {
            spdlog::error("Failed to deserialize ODB JSON at path '{}'", path);
            throw std::runtime_error("Failed to deserialize ODB JSON at path: " + path);
        }
        return parsed.value();
    }

    template <typename T>
    void write(const std::string& path, const T& obj) {
        auto j = json::parse(rfl::json::write(obj));
        write(path, j);
    }

    template <typename T>
    void initialize(const std::string& path, const T& obj) {
        auto j = json::parse(rfl::json::write(obj));
        initialize(path, j);
    }

private:
    HNDLE hDB_handle;

    enum class OdbMode { WRITE, INITIALIZE };
    void populateOdbHelper(const std::string& basePath, const json& j, OdbMode mode);

    json removeKeysContainingKey(const json& j);
    json readRecursive(HNDLE key, const std::string& fullPath);
};

#endif // ODB_MANAGER_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/midas/odb/odb_utils.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/midas/odb/odb_utils.h
Size: 3962 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_MIDAS_ODB_UTILS_H
#define SAMPIC_DAQ_INTEGRATION_MIDAS_ODB_UTILS_H

#include "midas.h"
#include <string>
#include <vector>
#include <spdlog/spdlog.h>

extern HNDLE hDB;

class OdbUtils {
public:
    // -------------------------------
    // Common frontend helpers
    // -------------------------------
    static void odbSetStatusColor(int frontend_index, const std::string& color) {
        char path[256];
        snprintf(path, sizeof(path),
                 "/Equipment/SAMPIC %02d/Common/Status color", frontend_index);

        if (db_set_value(hDB, 0, path, color.c_str(),
                         32, 1, TID_STRING) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set status color '{}' at '{}'", color, path);
        }
    }

    static void odbSetStatusMessage(int frontend_index, const std::string& message) {
        char path[256];
        snprintf(path, sizeof(path),
                 "/Equipment/SAMPIC %02d/Common/Status", frontend_index);

        if (db_set_value(hDB, 0, path, message.c_str(),
                         256, 1, TID_STRING) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set status message '{}' at '{}'", message, path);
        }
    }

    // -------------------------------
    // Generic scalar setters
    // -------------------------------
    static void odbSetString(const std::string& path, const std::string& value) {
        if (db_set_value(hDB, 0, path.c_str(),
                         value.c_str(), value.size() + 1, 1, TID_STRING) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set string '{}={}'", path, value);
        }
    }

    static void odbSetInt(const std::string& path, int value) {
        if (db_set_value(hDB, 0, path.c_str(),
                         &value, sizeof(value), 1, TID_INT32) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set int '{}={}'", path, value);
        }
    }

    static void odbSetBool(const std::string& path, bool value) {
        int v = value ? 1 : 0;
        if (db_set_value(hDB, 0, path.c_str(),
                         &v, sizeof(v), 1, TID_BOOL) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set bool '{}={}'", path, value);
        }
    }

    static void odbSetDouble(const std::string& path, double value) {
        if (db_set_value(hDB, 0, path.c_str(),
                         &value, sizeof(value), 1, TID_DOUBLE) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set double '{}={}'", path, value);
        }
    }

    // -------------------------------
    // Array setters
    // -------------------------------
    static void odbSetIntArray(const std::string& path, const std::vector<int>& values) {
        if (db_set_value(hDB, 0, path.c_str(),
                         values.data(), values.size() * sizeof(int),
                         values.size(), TID_INT32) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set int array at '{}'", path);
        }
    }

    static void odbSetDoubleArray(const std::string& path, const std::vector<double>& values) {
        if (db_set_value(hDB, 0, path.c_str(),
                         values.data(), values.size() * sizeof(double),
                         values.size(), TID_DOUBLE) != DB_SUCCESS) {
            spdlog::error("ODB: Failed to set double array at '{}'", path);
        }
    }

    static void odbSetStringArray(const std::string& path, const std::vector<std::string>& values) {
        for (size_t i = 0; i < values.size(); ++i) {
            std::string itemPath = path + "/" + std::to_string(i);
            if (db_set_value(hDB, 0, itemPath.c_str(),
                             values[i].c_str(), values[i].size() + 1,
                             1, TID_STRING) != DB_SUCCESS) {
                spdlog::error("ODB: Failed to set string array element '{}={}'", itemPath, values[i]);
            }
        }
    }
};

#endif // SAMPIC_DAQ_INTEGRATION_MIDAS_ODB_UTILS_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/modes/sampic_collector_mode.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/modes/sampic_collector_mode.h
Size: 1095 bytes
-----
#ifndef SAMPIC_COLLECTOR_MODE_H
#define SAMPIC_COLLECTOR_MODE_H

#include "integration/sampic/collector/sampic_event_buffer.h"
#include "integration/sampic/config/sampic_collector_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
}

/// Abstract base for all SAMPIC collector modes
class SampicCollectorMode {
public:
    SampicCollectorMode(CrateInfoStruct& info,
                        CrateParamStruct& params,
                        void* eventBuffer,
                        ML_Frame* mlFrames,
                        const SampicCollectorConfig& cfg)
        : info_(info), params_(params),
          eventBuffer_(eventBuffer), mlFrames_(mlFrames),
          cfg_(cfg) {}

    virtual ~SampicCollectorMode() = default;

    /// Perform one acquisition step, filling event + timing
    virtual int readEvent(EventStruct& event,
                          SampicEventTiming& timing) = 0;

protected:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    void* eventBuffer_;
    ML_Frame* mlFrames_;
    const SampicCollectorConfig& cfg_;
};

#endif // SAMPIC_COLLECTOR_MODE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/modes/sampic_collector_mode_default.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/modes/sampic_collector_mode_default.h
Size: 794 bytes
-----
#ifndef SAMPIC_COLLECTOR_MODE_DEFAULT_H
#define SAMPIC_COLLECTOR_MODE_DEFAULT_H

#include "integration/sampic/collector/modes/sampic_collector_mode.h"

/// Default collector mode:
/// Simple Prepare → Read → Decode per event.
class SampicCollectorModeDefault : public SampicCollectorMode {
public:
    SampicCollectorModeDefault(CrateInfoStruct& info,
                               CrateParamStruct& params,
                               void* eventBuffer,
                               ML_Frame* mlFrames,
                               const SampicCollectorConfig& cfg)
        : SampicCollectorMode(info, params, eventBuffer, mlFrames, cfg) {}

    int readEvent(EventStruct& event,
                  SampicEventTiming& timing) override;
};

#endif // SAMPIC_COLLECTOR_MODE_DEFAULT_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/modes/sampic_collector_mode_example.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/modes/sampic_collector_mode_example.h
Size: 786 bytes
-----
#ifndef SAMPIC_COLLECTOR_MODE_EXAMPLE_H
#define SAMPIC_COLLECTOR_MODE_EXAMPLE_H

#include "integration/sampic/collector/modes/sampic_collector_mode.h"

/// Example mode: placeholder for testing / prototyping custom logic.
class SampicCollectorModeExample : public SampicCollectorMode {
public:
    SampicCollectorModeExample(CrateInfoStruct& info,
                               CrateParamStruct& params,
                               void* eventBuffer,
                               ML_Frame* mlFrames,
                               const SampicCollectorConfig& cfg)
        : SampicCollectorMode(info, params, eventBuffer, mlFrames, cfg) {}

    int readEvent(EventStruct& event,
                  SampicEventTiming& timing) override;
};

#endif // SAMPIC_COLLECTOR_MODE_EXAMPLE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/sampic_collector.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/sampic_collector.h
Size: 1090 bytes
-----
#ifndef SAMPIC_COLLECTOR_H
#define SAMPIC_COLLECTOR_H

#include "integration/sampic/collector/sampic_event_buffer.h"
#include "integration/sampic/config/sampic_collector_config.h"
#include "integration/sampic/collector/modes/sampic_collector_mode.h"

#include <thread>
#include <atomic>
#include <memory>
#include <spdlog/spdlog.h>

extern "C" {
#include <SAMPIC_256Ch_lib.h>
}

class SampicCollector {
public:
    SampicCollector(const SampicCollectorConfig& cfg,
                    CrateInfoStruct& info,
                    CrateParamStruct& params,
                    void* eventBuffer,
                    ML_Frame* mlFrames);
    ~SampicCollector();

    void start();
    void stop();
    bool running() const { return running_; }

    SampicEventBuffer& buffer() { return *buffer_; }
    const SampicEventBuffer& buffer() const { return *buffer_; }

private:
    void run();

    SampicCollectorConfig cfg_;
    std::unique_ptr<SampicEventBuffer> buffer_;
    std::unique_ptr<SampicCollectorMode> mode_;

    std::thread worker_;
    std::atomic<bool> running_{false};
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/collector/sampic_event_buffer.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/collector/sampic_event_buffer.h
Size: 1828 bytes
-----
#ifndef SAMPIC_EVENT_BUFFER_H
#define SAMPIC_EVENT_BUFFER_H

#include <deque>
#include <mutex>
#include <condition_variable>
#include <optional>
#include <chrono>
#include <vector>
#include <memory>
#include <spdlog/spdlog.h>

extern "C" {
#include <SAMPIC_256Ch_Type.h>
}

/// Timing breakdown for diagnostics
struct SampicEventTiming {
    std::chrono::microseconds prepare_duration{0};
    std::chrono::microseconds read_duration{0};
    std::chrono::microseconds decode_duration{0};
    std::chrono::microseconds total_duration{0};
};

/// Wrapper: shared_ptr to EventStruct + timestamp + timing
struct TimestampedSampicEvent {
    std::shared_ptr<EventStruct> event;
    std::chrono::steady_clock::time_point timestamp;
    SampicEventTiming timing;
    bool consumed{false};
};

/// Thread-safe buffer for holding timestamped SAMPIC events
class SampicEventBuffer {
public:
    explicit SampicEventBuffer(size_t capacity);

    // Producer
    void push(const std::shared_ptr<EventStruct>& ev, 
              const SampicEventTiming& timing);

    // Consumer
    std::optional<TimestampedSampicEvent> pop();        ///< destructive
    std::optional<TimestampedSampicEvent> latest();     ///< peek latest, marks consumed
    std::vector<TimestampedSampicEvent> getSince(std::chrono::steady_clock::time_point t);

    // Polling helpers
    bool hasNewSince(std::chrono::steady_clock::time_point t) const;
    bool waitForNew(std::chrono::steady_clock::time_point t,
                    std::chrono::milliseconds timeout);

    // Info
    size_t size() const;
    bool empty() const;

private:
    size_t capacity_;
    mutable std::mutex mtx_;
    std::condition_variable cv_;
    std::deque<TimestampedSampicEvent> buffer_;
    std::chrono::steady_clock::time_point last_timestamp_;
};

#endif // SAMPIC_EVENT_BUFFER_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_board_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_board_configurator.h
Size: 1067 bytes
-----
#ifndef SAMPIC_BOARD_CONFIGURATOR_H
#define SAMPIC_BOARD_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_chip_configurator.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicBoardConfigurator {
public:
    SampicBoardConfigurator(int boardIdx,
                            CrateInfoStruct& info,
                            CrateParamStruct& params,
                            SampicFrontEndConfig& config);

    void apply();

    void setGlobalTrigger();     // SAMPIC256CH_SetFrontEndBoardGlobalTriggerOption
    void setLevel2ExtTrigGate(); // SAMPIC256CH_SetLevel2ExtTrigGate
    void setLevel2Coincidence(); // SAMPIC256CH_SetLevel2CoincidenceModeWithExtTrigGate

    void applyChips();

    //Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);
    int indexFromKey(const std::string& key);

private:
    int boardIdx_;
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicFrontEndConfig& config_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_channel_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_channel_configurator.h
Size: 1336 bytes
-----
#ifndef SAMPIC_CHANNEL_CONFIGURATOR_H
#define SAMPIC_CHANNEL_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicChannelConfigurator {
public:
    SampicChannelConfigurator(int boardIdx,
                              int chipIdx,
                              int channelIdx,
                              CrateInfoStruct& info,
                              CrateParamStruct& params,
                              SampicChannelConfig& config);

    void apply();

    void setMode();           // SAMPIC256CH_SetChannelMode
    void setTriggerMode();    // SAMPIC256CH_SetSampicChannelTriggerMode
    void setThreshold();      // SAMPIC256CH_SetSampicChannelInternalThreshold
    void setEdge();           // SAMPIC256CH_SetChannelSelflTriggerEdge
    void setExtThreshMode();  // SAMPIC256CH_SetSampicExternalThresholdMode
    void setSourceForCT();    // SAMPIC256CH_SetSampicChannelSourceForCT
    void setPulseMode();      // SAMPIC256CH_SetSampicChannelPulseMode

    //Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);

private:
    int boardIdx_;
    int chipIdx_;
    int channelIdx_;
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicChannelConfig& config_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_chip_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_chip_configurator.h
Size: 1593 bytes
-----
#ifndef SAMPIC_CHIP_CONFIGURATOR_H
#define SAMPIC_CHIP_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_channel_configurator.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicChipConfigurator {
public:
    SampicChipConfigurator(int boardIdx,
                           int chipIdx,
                           CrateInfoStruct& info,
                           CrateParamStruct& params,
                           SampicChipConfig& config);

    void apply();

    void setBaseline();               // SAMPIC256CH_SetBaselineReference
    void setExtThreshold();           // SAMPIC256CH_SetSampicExternalThreshold
    void setTOTRange();               // SAMPIC256CH_SetSampicTOTRange
    void setPostTrigger();            // SAMPIC256CH_SetSampicPostTrigParams

    void setCentralTriggerMode();     // SAMPIC256CH_SetSampicCentralTriggerMode
    void setCentralTriggerEffect();   // SAMPIC256CH_SetSampicCentralTriggerEffect
    void setCentralTriggerPrimitives(); // SAMPIC256CH_SetSampicCentralTriggerPrimitivesOptions

    void setTriggerOption();          // SAMPIC256CH_SetSampicTriggerOption
    void setTOTFilterParams();        // SAMPIC256CH_SetSampicTOTFilterParams

    void applyChannels();

    //Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);
    int indexFromKey(const std::string& key);

private:
    int boardIdx_;
    int chipIdx_;
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicChipConfig& config_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_collector_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_collector_config.h
Size: 864 bytes
-----
#ifndef SAMPIC_COLLECTOR_CONFIG_H
#define SAMPIC_COLLECTOR_CONFIG_H

#include <cstddef>
#include <string>

/// Modes for the collector loop
enum class SampicCollectorModeType {
    DEFAULT,
    EXAMPLE
};

/// Configuration for SampicCollector
struct SampicCollectorConfig {
    SampicCollectorModeType mode = SampicCollectorModeType::EXAMPLE;

    // Buffering
    size_t buffer_size = 128;      // number of events the buffer can hold

    // Timing
    int sleep_time_us = 1000000;    // microseconds to sleep between collector loop polls

    // Acquisition loop
    int soft_trigger_prepare_interval = 100;     // how often to re-call PrepareEvent
    int soft_trigger_max_loops        = 10000;   // max loops before timing out
    int soft_trigger_retry_sleep_us   = 100;     // NEW: sleep between failed read retries
};

#endif // SAMPIC_COLLECTOR_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_controller_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_controller_config.h
Size: 502 bytes
-----
#ifndef SAMPIC_CONTROLLER_CONFIG_H
#define SAMPIC_CONTROLLER_CONFIG_H

#include <cstddef>

enum class SampicInitSettingsModeType {
    DEFAULT,
    EXAMPLE
};

enum class SampicApplySettingsModeType {
    DEFAULT,
    EXAMPLE
};

struct SampicControllerConfig {
    // Independent mode switches
    SampicInitSettingsModeType  init_mode  = SampicInitSettingsModeType::EXAMPLE;
    SampicApplySettingsModeType apply_mode = SampicApplySettingsModeType::EXAMPLE;

};

#endif // SAMPIC_CONTROLLER_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_crate_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_crate_config.h
Size: 7442 bytes
-----
#ifndef SAMPIC_CONFIG_H
#define SAMPIC_CONFIG_H

#include <string>
#include <cstdint>
#include <map>

extern "C" {
#include <SAMPIC_256Ch_Type.h>
}

// ==============================
// Channel (lowest level)
// ==============================
struct SampicChannelConfig {
  bool                         enabled  = true;                          // Global enable for channel
  SAMPIC_ChannelTriggerMode_t  trigger_mode = SAMPIC_CHANNEL_EXT_TRIGGER_MODE; // SAMPIC256CH_SetSampicChannelTriggerMode
  float                        internal_threshold = 0.0;                 // SAMPIC256CH_SetSampicChannelInternalThreshold
  EdgeType_t                   trigger_edge = RISING_EDGE;               // SAMPIC256CH_SetChannelSelflTriggerEdge
  bool                         external_threshold_mode = false;          // SAMPIC256CH_SetSampicExternalThresholdMode
  bool                         enable_for_central_trigger = true;        // SAMPIC256CH_SetSampicChannelSourceForCT
  bool                         pulse_mode = false;                       // SAMPIC256CH_SetSampicChannelPulseMode
};

using SampicChannelSettings = std::map<std::string, SampicChannelConfig>;

// ==============================
// Chip (contains channels)
// ==============================
struct SampicChipConfig {
  bool                          enabled = true;                          // Global enable for chip

  float                         baseline_reference = DEFAULT_SAMPIC_BASELINE; // SAMPIC256CH_SetBaselineReference
  float                         external_threshold = 0.5;                    // SAMPIC256CH_SetSampicExternalThreshold

  SAMPIC_TOTRange_t             tot_range = SAMPIC_TOT_RANGE_MAX_25_NS;       // SAMPIC256CH_SetSampicTOTRange
  bool                          enable_post_trigger = true;                  // SAMPIC256CH_SetSampicPostTrigParams
  int                           post_trigger_value = 7;                       // SAMPIC256CH_SetSampicPostTrigParams

  SampicCentralTriggerMode_t    central_trigger_mode   = CENTRAL_OR;          // SAMPIC256CH_SetSampicCentralTriggerMode
  SampicCentralTriggerEffect_t  central_trigger_effect = TRIG_CHANNEL_ONLY_IF_PARTICIPATING_TO_CT; // SAMPIC256CH_SetSampicCentralTriggerEffect
  SAMPIC_CT_PrimitivesMode_t    primitives_mode        = RAW_PRIMITIVES_FOR_CT; // SAMPIC256CH_SetSampicCentralTriggerPrimitivesOptions
  int                           primitives_gate_length = DEFAULT_PRIMITIVES_GATE_LENGTH; // SAMPIC256CH_SetSampicCentralTriggerPrimitivesOptions

  bool   tot_filter_enable = false;   // SAMPIC256CH_SetSampicTOTFilterParams
  bool   tot_wide_cap      = false;   // SAMPIC256CH_SetSampicTOTFilterParams
  float  tot_min_width_ns  = 0.0;     // SAMPIC256CH_SetSampicTOTFilterParams

  SampicChannelSettings channels {
    {"channel0", {}}, {"channel1", {}}, {"channel2", {}}, {"channel3", {}},
    {"channel4", {}}, {"channel5", {}}, {"channel6", {}}, {"channel7", {}},
    {"channel8", {}}, {"channel9", {}}, {"channel10", {}}, {"channel11", {}},
    {"channel12", {}}, {"channel13", {}}, {"channel14", {}}, {"channel15", {}}
  };
};

using SampicChipSettings = std::map<std::string, SampicChipConfig>;

// ==============================
// Board (contains chips)
// ==============================
struct SampicFrontEndConfig {
  bool enabled = true;   // Global enable for this FE board

  FebGlobalTrigger_t global_trigger_option = FEB_GLOBAL_TRIGGER_IS_L2;       // SAMPIC256CH_SetFrontEndBoardGlobalTriggerOption

  unsigned char     level2_ext_trig_gate  = DEFAULT_EXT_TRIG_GATE;           // SAMPIC256CH_SetLevel2ExtTrigGate
  bool              level2_coincidence_ext_gate = false;                     // SAMPIC256CH_SetLevel2CoincidenceModeWithExtTrigGate

  SampicChipSettings sampics {
    {"sampic0", {}}, {"sampic1", {}}, {"sampic2", {}}, {"sampic3", {}}
  };
};

using SampicFrontEndSettings = std::map<std::string, SampicFrontEndConfig>;

// ==============================
// Crate (top-level system)
// ==============================
struct SampicSystemSettings {
  std::string    ip_address     = "192.168.0.4"; //DEFAULT_CTRL_IP_ADDRESS
  int            port           = DEFAULT_UDP_CTRL_PORT;   // UDP control port
  ConnectionType_t connection_type = UDP_CONNECTION;       // SAMPIC256CH_OpenCrateConnection
  ControlType_t    control_type    = CTRL_AND_DAQ;         // SAMPIC256CH_OpenCrateConnection

  // Acquisition
  int  sampling_frequency_mhz = DEFAULT_FREQ_ECH;   // SAMPIC256CH_SetSamplingFrequency
  bool use_external_clock     = false;
  int  frames_per_block       = MAX_NB_OF_FRAMES_PER_BLOCK;  // SAMPIC256CH_SetNbOfFramesPerBlock
  bool enable_tot             = false;              // SAMPIC256CH_SetTOTMeasurementMode
  int  adc_bits               = DEFAULT_ADC_NB_OF_BITS; // Set_SystemADCNbOfBits
  bool smart_read_mode        = false;              // SAMPIC256CH_SetSmartReadMode
  int  read_offset            = 0;
  int  samples_to_read        = MAX_NB_OF_SAMPLES;

  // Trigger
  ExternalTriggerType_t external_trigger_type = SOFTWARE;      // SAMPIC256CH_SetExternalTriggerType
  SignalLevel_t         signal_level          = TTL_SIG;       // SAMPIC256CH_SetExternalTriggerSigLevel
  EdgeType_t            trigger_edge          = RISING_EDGE;   // SAMPIC256CH_SetExternalTriggerEdge
  std::uint8_t          triggers_per_event    = DEFAULT_NB_OF_TRIGGERS_PER_TRIGGER_EVENT; // SAMPIC256CH_SetMinNbOfTriggersPerEvent
  bool                  level2_trigger_build  = false;         // SAMPIC256CH_SetLevel2TriggerBuildOption
  bool                  level3_trigger_build  = false;         // SAMPIC256CH_SetLevel3TriggerLogic
  SampicTriggerOption_t trigger_option        = SAMPIC_TRIGGER_IS_L1; // SAMPIC256CH_SetSampicTriggerOption
  unsigned char         level3_ext_trig_gate  = DEFAULT_EXT_TRIG_GATE; // SAMPIC256CH_SetLevel3ExtTrigGate
  bool                  level3_coincidence_ext_gate = false;   // SAMPIC256CH_SetLevel3CoincidenceModeWithExtTrigGate
  unsigned char         primitives_gate_length = DEFAULT_PRIMITIVES_GATE_LENGTH; // SAMPIC256CH_SetPrimitivesGateLength
  unsigned char         latency_gate_length    = DEFAULT_LEVEL_2_LATENCY_GATE;   // SAMPIC256CH_SetLevel2LatencyGateLength

  // Pulser
  bool               pulser_enable      = false;           // SAMPIC256CH_SetPulserMode
  PulserSourceType_t pulser_source      = PULSER_SRC_IS_SOFT_CMD;
  bool               pulser_synchronous = true;
  int                pulser_period      = DEFAULT_AUTO_PULSE_PERIOD;   // SAMPIC256CH_SetAutoPulserPeriod
  unsigned char      pulser_width       = DEFAULT_PULSER_WIDTH;        // SAMPIC256CH_SetSampicPulserWidth

  // Sync + corrections
  bool        sync_mode        = false;           // SAMPIC256CH_SetCrateSycnhronisationMode
  bool        master_mode      = false;
  bool        coincidence_mode = false;
  EdgeType_t  sync_edge        = RISING_EDGE;     // SAMPIC256CH_SetExternalSyncEdge
  SignalLevel_t sync_level     = TTL_SIG;         // SAMPIC256CH_SetExternalSyncSigLevel

  bool        adc_linearity_correction   = false; // SAMPIC256CH_SetCrateCorrectionLevels
  bool        time_inl_correction        = false;
  bool        residual_pedestal_correction = false;
  std::string calibration_directory      = "resources/calib";   // SAMPIC256CH_LoadAllCalibValuesFromFiles

  SampicFrontEndSettings    front_end_boards {
    {"feb0", {}}, {"feb1", {}}, {"feb2", {}}, {"feb3", {}}
  };
};

#endif // SAMPIC_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/config/sampic_crate_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/config/sampic_crate_configurator.h
Size: 2413 bytes
-----
#ifndef SAMPIC_CRATE_CONFIGURATOR_H
#define SAMPIC_CRATE_CONFIGURATOR_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_board_configurator.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicCrateConfigurator {
public:
    SampicCrateConfigurator(CrateInfoStruct& info,
                            CrateParamStruct& params,
                            SampicSystemSettings& settings);

    void apply();

    // Acquisition
    void setSamplingFrequency();     // SAMPIC256CH_SetSamplingFrequency
    void setFramesPerBlock();        // SAMPIC256CH_SetNbOfFramesPerBlock
    void setTOTMode();               // SAMPIC256CH_SetTOTMeasurementMode
    void setADCBits();               // Set_SystemADCNbOfBits
    void setSmartReadMode();         // SAMPIC256CH_SetSmartReadMode

    // External triggers
    void setExternalTriggerType();   // SAMPIC256CH_SetExternalTriggerType
    void setExternalTriggerLevel();  // SAMPIC256CH_SetExternalTriggerSigLevel
    void setExternalTriggerEdge();   // SAMPIC256CH_SetExternalTriggerEdge
    void setMinTriggersPerEvent();   // SAMPIC256CH_SetMinNbOfTriggersPerEvent
    void setLevel2TriggerBuild();    // SAMPIC256CH_SetLevel2TriggerBuildOption
    void setLevel3TriggerBuild();    // SAMPIC256CH_SetLevel3TriggerLogic

    // Gates
    void setPrimitivesGateLength();          // SAMPIC256CH_SetPrimitivesGateLength
    void setLevel2LatencyGateLength();       // SAMPIC256CH_SetLevel2LatencyGateLength
    void setLevel3ExtTrigGate();             // SAMPIC256CH_SetLevel3ExtTrigGate
    void setLevel3CoincidenceWithExtGate();  // SAMPIC256CH_SetLevel3CoincidenceModeWithExtTrigGate

    // Pulser
    void setPulser();                // Pulser settings

    // Sync + corrections
    void setSyncMode();              // SAMPIC256CH_SetCrateSycnhronisationMode
    void setSyncEdge();              // SAMPIC256CH_SetExternalSyncEdge
    void setSyncLevel();             // SAMPIC256CH_SetExternalSyncSigLevel
    void setCorrectionLevels();      // SAMPIC256CH_SetCrateCorrectionLevels

    // Boards
    void applyBoards();

    //Helpers
    void check(SAMPIC256CH_ErrCode code, const std::string& what);
    int indexFromKey(const std::string& key);

private:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicSystemSettings& settings_;
};

#endif

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h
Size: 1306 bytes
-----
#ifndef SAMPIC_APPLY_SETTINGS_MODE_H
#define SAMPIC_APPLY_SETTINGS_MODE_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_crate_configurator.h"
#include "integration/sampic/config/sampic_board_configurator.h"
#include "integration/sampic/config/sampic_chip_configurator.h"
#include "integration/sampic/config/sampic_channel_configurator.h"
#include "integration/sampic/config/sampic_controller_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

/// Abstract base for all "apply settings" modes
class SampicApplySettingsMode {
public:
    SampicApplySettingsMode(CrateInfoStruct& info,
                            CrateParamStruct& params,
                            SampicSystemSettings& settings,
                            const SampicControllerConfig& controllerCfg)
        : info_(info),
          params_(params),
          settings_(settings),
          controllerCfg_(controllerCfg) {}

    virtual ~SampicApplySettingsMode() = default;

    /// Apply settings to hardware
    virtual void apply() = 0;

protected:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    SampicSystemSettings& settings_;
    const SampicControllerConfig& controllerCfg_;
};

#endif // SAMPIC_APPLY_SETTINGS_MODE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h
Size: 461 bytes
-----
#ifndef SAMPIC_APPLY_SETTINGS_MODE_DEFAULT_H
#define SAMPIC_APPLY_SETTINGS_MODE_DEFAULT_H

#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h"

/// Default mode: applies ALL settings using configurators
class SampicApplySettingsModeDefault : public SampicApplySettingsMode {
public:
    using SampicApplySettingsMode::SampicApplySettingsMode;

    void apply() override;
};

#endif // SAMPIC_APPLY_SETTINGS_MODE_DEFAULT_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h
Size: 524 bytes
-----
#ifndef SAMPIC_APPLY_SETTINGS_MODE_EXAMPLE_H
#define SAMPIC_APPLY_SETTINGS_MODE_EXAMPLE_H

#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h"

/// Example mode: simplified trigger-only application,
/// but still through configurators so we can modify channels etc.
class SampicApplySettingsModeExample : public SampicApplySettingsMode {
public:
    using SampicApplySettingsMode::SampicApplySettingsMode;

    void apply() override;
};

#endif // SAMPIC_APPLY_SETTINGS_MODE_EXAMPLE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h
Size: 1182 bytes
-----
#ifndef SAMPIC_INIT_SETTINGS_MODE_H
#define SAMPIC_INIT_SETTINGS_MODE_H

#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_controller_config.h"

extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

class SampicInitSettingsMode {
public:
    SampicInitSettingsMode(CrateInfoStruct& info,
                           CrateParamStruct& params,
                           void*& eventBuffer,
                           ML_Frame*& mlFrames,
                           const SampicSystemSettings& settings,
                           const SampicControllerConfig& controllerCfg)
        : info_(info),
          params_(params),
          eventBuffer_(eventBuffer),
          mlFrames_(mlFrames),
          settings_(settings),
          controllerCfg_(controllerCfg) {}

    virtual ~SampicInitSettingsMode() = default;

    virtual int initialize() = 0;

protected:
    CrateInfoStruct& info_;
    CrateParamStruct& params_;
    void*& eventBuffer_;
    ML_Frame*& mlFrames_;
    const SampicSystemSettings& settings_;
    const SampicControllerConfig& controllerCfg_;
};

#endif // SAMPIC_INIT_SETTINGS_MODE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h
Size: 396 bytes
-----
#ifndef SAMPIC_INIT_SETTINGS_MODE_DEFAULT_H
#define SAMPIC_INIT_SETTINGS_MODE_DEFAULT_H

#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h"

class SampicInitSettingsModeDefault : public SampicInitSettingsMode {
public:
    using SampicInitSettingsMode::SampicInitSettingsMode;
    int initialize() override;
};

#endif // SAMPIC_INIT_SETTINGS_MODE_DEFAULT_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h
Size: 396 bytes
-----
#ifndef SAMPIC_INIT_SETTINGS_MODE_EXAMPLE_H
#define SAMPIC_INIT_SETTINGS_MODE_EXAMPLE_H

#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h"

class SampicInitSettingsModeExample : public SampicInitSettingsMode {
public:
    using SampicInitSettingsMode::SampicInitSettingsMode;
    int initialize() override;
};

#endif // SAMPIC_INIT_SETTINGS_MODE_EXAMPLE_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/sampic/controller/sampic_controller.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/sampic/controller/sampic_controller.h
Size: 2792 bytes
-----
#ifndef SAMPIC_CONTROLLER_H
#define SAMPIC_CONTROLLER_H

#include <memory>
#include <spdlog/spdlog.h>

// External SAMPIC lib
extern "C" {
#include <SAMPIC_256Ch_lib.h>
#include <SAMPIC_256Ch_Type.h>
}

// Project configs + components
#include "integration/sampic/config/sampic_crate_config.h"
#include "integration/sampic/config/sampic_controller_config.h"
#include "integration/sampic/config/sampic_collector_config.h"
#include "integration/sampic/collector/sampic_collector.h"
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode.h"
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode.h"

/// High-level orchestrator for SAMPIC system
class SampicController {
public:
    SampicController(const SampicSystemSettings& sys_cfg,
                     const SampicControllerConfig& ctrl_cfg,
                     const SampicCollectorConfig& coll_cfg);

    ~SampicController();

    // ---------------- Config management ----------------
    void setSystemSettings(const SampicSystemSettings& s);
    SampicSystemSettings& systemSettings();
    const SampicSystemSettings& systemSettings() const;

    void setControllerConfig(const SampicControllerConfig& c);
    SampicControllerConfig& controllerConfig();
    const SampicControllerConfig& controllerConfig() const;

    void setCollectorConfig(const SampicCollectorConfig& c);
    SampicCollectorConfig& collectorConfig();
    const SampicCollectorConfig& collectorConfig() const;

    // ---------------- Lifecycle ----------------
    int initialize();       ///< Initialize hardware (crate connection, params, calib, memory)
    int applySettings();    ///< Apply settings (trigger options etc.)
    int startRun();         ///< Start acquisition
    int stopRun();          ///< Stop acquisition
    void cleanup();         ///< Free resources, close connection

    // ---------------- Collector ----------------
    void startCollector();
    void stopCollector();

    // ---------------- Buffer access ----------------
    SampicEventBuffer& buffer();
    const SampicEventBuffer& buffer() const;

private:
    // Configs
    SampicSystemSettings   settings_;
    SampicControllerConfig ctrl_cfg_;
    SampicCollectorConfig  coll_cfg_;

    // Hardware handles
    CrateInfoStruct info_{};
    CrateParamStruct params_{};
    void* eventBuffer_{nullptr};
    ML_Frame* mlFrames_{nullptr};

    // Collector (owns its buffer)
    std::unique_ptr<SampicCollector> collector_;

    // Init/apply strategies
    std::unique_ptr<SampicInitSettingsMode> init_mode_;
    std::unique_ptr<SampicApplySettingsMode> apply_mode_;

    // State
    bool initialized_{false};
    bool run_started_{false};
    bool collector_running_{false};
};

#endif // SAMPIC_CONTROLLER_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/spdlog/logger_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/spdlog/logger_config.h
Size: 939 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIG_H
#define SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIG_H

#include <string>

// Configuration for spdlog logger setup.
// Define parameters to be read from ODB or config files.
struct LoggerConfig {
    std::string name = "SAMPIC_DAQ";         // logger name (shows up in [%n])
    std::string log_level = "info";         // e.g., "trace", "debug", "info", "warn", "error"
    std::string log_pattern = "[%T] [%^%l%$] [%n] %v"; // include [%n] for logger name
    std::string log_file = "frontend.log";  // optional log file path
    bool to_console = true;                 // enable logging to console
    bool to_file = false;                   // enable logging to file
    size_t max_file_size = 5 * 1024 * 1024; // 5 MB for rotating file sink
    size_t max_files = 3;                   // number of rotated files to keep
};


#endif // SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIG_H

===== FILE END =====

===== FILE START =====
Relative Path: include/integration/spdlog/logger_configurator.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/integration/spdlog/logger_configurator.h
Size: 454 bytes
-----
#ifndef SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIGURATOR_H
#define SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIGURATOR_H

#include "integration/spdlog/logger_config.h"

class LoggerConfigurator {
public:
    // Configure global spdlog default logger from ODB/struct settings
    static void configure(const LoggerConfig& cfg);

private:
    LoggerConfigurator() = default; // no instances
};

#endif // SAMPIC_DAQ_INTEGRATION_SPDLOG_LOGGER_CONFIGURATOR_H

===== FILE END =====

===== FILE START =====
Relative Path: include/processing/sampic_processing/collector/frontend_event_buffer.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/processing/sampic_processing/collector/frontend_event_buffer.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: include/processing/sampic_processing/collector/frontend_event_collector.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/processing/sampic_processing/collector/frontend_event_collector.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: include/processing/sampic_processing/config/frontend_event_collector_config.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/include/processing/sampic_processing/config/frontend_event_collector_config.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/midas/odb/odb_manager.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/midas/odb/odb_manager.cpp
Size: 8658 bytes
-----
#include "integration/midas/odb/odb_manager.h"
#include <cstring>

// --- JSON/String API ---
std::string OdbManager::read(const std::string& path) {
    json j = read(path, false);
    return j.dump();
}

json OdbManager::read(const std::string& path, bool /*unused*/) {
    HNDLE key;
    if (db_find_key(hDB_handle, 0, path.c_str(), &key) != DB_SUCCESS) {
        // Commented out because this is sometimes expected behavior
        // spdlog::warn("ODB key '{}' not found", path);
        return nullptr;
    }
    return readRecursive(key, path);
}

// --- Recursive reader with full path ---
json OdbManager::readRecursive(HNDLE key, const std::string& fullPath) {
    json result;

    INT type = 0, num_values = 0, item_size = 0;
    char name[128] = {0};

    INT ret = db_get_key_info(hDB_handle, key, name, sizeof(name), &type, &num_values, &item_size);
    if (ret != DB_SUCCESS) {
        spdlog::error("db_get_key_info failed for path '{}'", fullPath);
        return result;
    }

    // Container keys (struct/array) or any node with subkeys
    HNDLE subkey;
    INT idx = 0;
    bool hasSubkeys = false;
    while (db_enum_key(hDB_handle, key, idx, &subkey) == DB_SUCCESS) {
        hasSubkeys = true;
        char subname[128] = {0};
        INT sub_type = 0, sub_num_values = 0, sub_item_size = 0;
        if (db_get_key_info(hDB_handle, subkey, subname, sizeof(subname),
                            &sub_type, &sub_num_values, &sub_item_size) == DB_SUCCESS) {
            std::string subPath = fullPath + "/" + subname;
            result[subname] = readRecursive(subkey, subPath);
        }
        ++idx;
    }

    if (hasSubkeys)
        return result;

    // Scalar leaf keys
    switch (type) {
        case TID_UINT8: case TID_INT8: case TID_UINT16: case TID_INT16:
        case TID_UINT32: case TID_INT32: case TID_INT64: case TID_UINT64: {
            int64_t val = 0;
            int read_size = item_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), &val, &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = val;
            else spdlog::error("db_get_value failed for path '{}' (int)", fullPath);
            break;
        }
        case TID_FLOAT32: case TID_FLOAT64: {
            double val = 0;
            int read_size = item_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), &val, &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = val;
            else spdlog::error("db_get_value failed for path '{}' (float)", fullPath);
            break;
        }
        case TID_BOOL: {
            int val = 0;
            int read_size = item_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), &val, &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = (val != 0);
            else spdlog::error("db_get_value failed for path '{}' (bool)", fullPath);
            break;
        }
        case TID_STRING: {
            int buf_size = std::max(item_size, 1);
            std::vector<char> buf(buf_size, 0);
            int read_size = buf_size;
            ret = db_get_value(hDB_handle, 0, fullPath.c_str(), buf.data(), &read_size, type, FALSE);
            if (ret == DB_SUCCESS) result = std::string(buf.data(), read_size);
            else spdlog::error("db_get_value failed for path '{}' (string)", fullPath);
            break;
        }
        default:
            spdlog::warn("Unsupported ODB type {} at path '{}'", type, fullPath);
            break;
    }

    return result;
}

// --- Write / Initialize API ---
void OdbManager::write(const std::string& path, const std::string& jsonStr) {
    write(path, json::parse(jsonStr));
}

void OdbManager::write(const std::string& path, const json& j) {
    spdlog::info("Writing to ODB at '{}'", path);
    populateOdbHelper(path, j, OdbMode::WRITE);
}

void OdbManager::initialize(const std::string& path, const std::string& jsonStr) {
    initialize(path, json::parse(jsonStr));
}

void OdbManager::initialize(const std::string& path, const json& j) {
    // Don't need this info, plus we need to call this before logger is initialized
    // spdlog::info("Initializing ODB at '{}'", path); 
    populateOdbHelper(path, j, OdbMode::INITIALIZE);
}

// --- Populate ODB recursively ---
void OdbManager::populateOdbHelper(const std::string& basePath, const json& j, OdbMode mode) {
    HNDLE key;
    bool exists = (db_find_key(hDB_handle, 0, basePath.c_str(), &key) == DB_SUCCESS);

    if (j.is_object()) {
        // Ensure directory key exists
        if (!exists && mode == OdbMode::INITIALIZE) {
            db_create_key(hDB_handle, 0, basePath.c_str(), TID_KEY);
        }
        // Recurse on object fields
        for (auto& [subkey, value] : j.items()) {
            std::string fullPath = basePath + "/" + subkey;
            populateOdbHelper(fullPath, value, mode);
        }
    }
    else if (j.is_array()) {
        if (j.empty()) return;

        // Ensure array key exists
        if (!exists && mode == OdbMode::INITIALIZE) {
            db_create_key(hDB_handle, 0, basePath.c_str(), TID_KEY);
        }

        // Detect primitive array vs object array
        if (j.front().is_primitive()) {
            if (mode == OdbMode::INITIALIZE && exists) {
                return; // skip existing arrays
            }

            if (j.front().is_string()) {
                std::vector<std::string> vals;
                for (auto& v : j) vals.push_back(v.get<std::string>());
                for (size_t i = 0; i < vals.size(); i++) {
                    std::string itemPath = basePath + "/" + std::to_string(i);
                    db_set_value(hDB_handle, 0, itemPath.c_str(),
                                 vals[i].c_str(), vals[i].size() + 1, 1, TID_STRING);
                }
            }
            else if (j.front().is_boolean()) {
                std::vector<int> vals;
                for (auto& v : j) vals.push_back(v.get<bool>() ? 1 : 0);
                db_set_value(hDB_handle, 0, basePath.c_str(),
                             vals.data(), sizeof(int) * vals.size(), vals.size(), TID_BOOL);
            }
            else if (j.front().is_number_float()) {
                std::vector<double> vals;
                for (auto& v : j) vals.push_back(v.get<double>());
                db_set_value(hDB_handle, 0, basePath.c_str(),
                             vals.data(), sizeof(double) * vals.size(), vals.size(), TID_FLOAT64);
            }
            else if (j.front().is_number_integer()) {
                std::vector<int64_t> vals;
                for (auto& v : j) vals.push_back(v.get<int64_t>());
                db_set_value(hDB_handle, 0, basePath.c_str(),
                             vals.data(), sizeof(int64_t) * vals.size(), vals.size(), TID_INT64);
            }
        }
        else {
            // Array of objects → recurse
            for (size_t i = 0; i < j.size(); ++i) {
                std::string itemPath = basePath + "/" + std::to_string(i);
                populateOdbHelper(itemPath, j[i], mode);
            }
        }
    }
    else if (j.is_primitive()) {
        // Skip existing values in INITIALIZE mode
        if (mode == OdbMode::INITIALIZE && exists) {
            return;
        }

        // Scalars
        if (j.is_string()) {
            std::string s = j;
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         s.c_str(), s.size() + 1, 1, TID_STRING);
        }
        else if (j.is_boolean()) {
            int b = j.get<bool>() ? 1 : 0;
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         &b, sizeof(int), 1, TID_BOOL);
        }
        else if (j.is_number_float()) {
            double d = j.get<double>();
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         &d, sizeof(double), 1, TID_FLOAT64);
        }
        else if (j.is_number_integer()) {
            int64_t v = j.get<int64_t>();
            db_set_value(hDB_handle, 0, basePath.c_str(),
                         &v, sizeof(int64_t), 1, TID_INT64);
        }
    }
}



// --- Utility ---
json OdbManager::removeKeysContainingKey(const json& j) {
    json result = j;
    for (auto it = result.begin(); it != result.end(); ) {
        if (it.key().find("/key") != std::string::npos) {
            spdlog::debug("Removing JSON key '{}'", it.key());
            it = result.erase(it);
        } else {
            if (it.value().is_object() || it.value().is_array()) {
                it.value() = removeKeysContainingKey(it.value());
            }
            ++it;
        }
    }
    return result;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/modes/sampic_collector_mode_default.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/modes/sampic_collector_mode_default.cpp
Size: 2508 bytes
-----
#include "integration/sampic/collector/modes/sampic_collector_mode_default.h"
#include <spdlog/spdlog.h>

int SampicCollectorModeDefault::readEvent(EventStruct& event,
                                          SampicEventTiming& timing) {
    auto t_start = std::chrono::steady_clock::now();
    SAMPIC256CH_PrepareEvent(&info_, &params_);
    auto t_after_prepare = std::chrono::steady_clock::now();

    SAMPIC256CH_ErrCode errCode = SAMPIC256CH_NoFrameRead;
    int numberOfHits = 0;
    int nframes = 0;
    int dummy = 0;
    int nloop_for_soft_trig = 0;

    while (errCode != SAMPIC256CH_Success) {
        auto t_read_start = std::chrono::steady_clock::now();
        errCode = SAMPIC256CH_ReadEventBuffer(&info_, dummy, eventBuffer_, mlFrames_, &nframes);
        auto t_read_end = std::chrono::steady_clock::now();

        if (errCode == SAMPIC256CH_Success) {
            auto t_decode_start = std::chrono::steady_clock::now();
            errCode = SAMPIC256CH_DecodeEvent(&info_, &params_, mlFrames_, &event, nframes, &numberOfHits);
            auto t_decode_end = std::chrono::steady_clock::now();

            timing.decode_duration =
                std::chrono::duration_cast<std::chrono::microseconds>(t_decode_end - t_decode_start);
        }

        timing.read_duration +=
            std::chrono::duration_cast<std::chrono::microseconds>(t_read_end - t_read_start);

        if (errCode == SAMPIC256CH_AcquisitionError || errCode == SAMPIC256CH_ErrInvalidEvent) {
            spdlog::error("Default mode: Acquisition error (err={})", static_cast<int>(errCode));
            return -1;
        }

        if ((nloop_for_soft_trig % cfg_.soft_trigger_prepare_interval) == 0) {
            SAMPIC256CH_PrepareEvent(&info_, &params_);
        }
        nloop_for_soft_trig++;

        if (nloop_for_soft_trig > cfg_.soft_trigger_max_loops) {
            spdlog::warn("Default mode: Timeout after {} loops", cfg_.soft_trigger_max_loops);
            return 0;
        }
    }

    timing.prepare_duration =
        std::chrono::duration_cast<std::chrono::microseconds>(t_after_prepare - t_start);

    if (errCode == SAMPIC256CH_Success && numberOfHits > 0) {
        spdlog::debug("Default mode: Collected {} hits (prepare={}us, read={}us, decode={}us)",
                      numberOfHits,
                      timing.prepare_duration.count(),
                      timing.read_duration.count(),
                      timing.decode_duration.count());
    }

    return numberOfHits;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/modes/sampic_collector_mode_example.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/modes/sampic_collector_mode_example.cpp
Size: 2816 bytes
-----
#include "integration/sampic/collector/modes/sampic_collector_mode_example.h"
#include <spdlog/spdlog.h>
#include <thread>   // for sleep_for

int SampicCollectorModeExample::readEvent(EventStruct& event,
                                          SampicEventTiming& timing) {
    auto t_start = std::chrono::steady_clock::now();
    SAMPIC256CH_PrepareEvent(&info_, &params_);
    auto t_after_prepare = std::chrono::steady_clock::now();

    SAMPIC256CH_ErrCode errCode = SAMPIC256CH_NoFrameRead;
    int numberOfHits = 0;
    int nframes = 0;
    int dummy = 0;
    int nloop_for_soft_trig = 0;

    while (errCode != SAMPIC256CH_Success) {
        auto t_read_start = std::chrono::steady_clock::now();
        errCode = SAMPIC256CH_ReadEventBuffer(&info_, dummy, eventBuffer_, mlFrames_, &nframes);
        auto t_read_end = std::chrono::steady_clock::now();

        if (errCode == SAMPIC256CH_Success) {
            auto t_decode_start = std::chrono::steady_clock::now();
            errCode = SAMPIC256CH_DecodeEvent(&info_, &params_, mlFrames_, &event, nframes, &numberOfHits);
            auto t_decode_end = std::chrono::steady_clock::now();

            timing.decode_duration =
                std::chrono::duration_cast<std::chrono::microseconds>(t_decode_end - t_decode_start);
        }

        timing.read_duration +=
            std::chrono::duration_cast<std::chrono::microseconds>(t_read_end - t_read_start);

        if (errCode == SAMPIC256CH_AcquisitionError || errCode == SAMPIC256CH_ErrInvalidEvent) {
            spdlog::error("Example mode: Acquisition error (err={})", static_cast<int>(errCode));
            return -1;
        }

        if ((nloop_for_soft_trig % cfg_.soft_trigger_prepare_interval) == 0) {
            SAMPIC256CH_PrepareEvent(&info_, &params_);
        }
        nloop_for_soft_trig++;

        if (nloop_for_soft_trig > cfg_.soft_trigger_max_loops) {
            spdlog::warn("Example mode: Timeout after {} loops", cfg_.soft_trigger_max_loops);
            return 0;
        }

        // NEW: avoid pegging CPU if repeated failures
        if (errCode != SAMPIC256CH_Success && cfg_.soft_trigger_retry_sleep_us > 0) {
            std::this_thread::sleep_for(
                std::chrono::microseconds(cfg_.soft_trigger_retry_sleep_us));
        }
    }

    timing.prepare_duration =
        std::chrono::duration_cast<std::chrono::microseconds>(t_after_prepare - t_start);

    if (errCode == SAMPIC256CH_Success && numberOfHits > 0) {
        spdlog::debug("Example mode: Collected {} hits (prepare={}us, read={}us, decode={}us)",
                      numberOfHits,
                      timing.prepare_duration.count(),
                      timing.read_duration.count(),
                      timing.decode_duration.count());
    }

    return numberOfHits;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/sampic_collector.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/sampic_collector.cpp
Size: 2125 bytes
-----
#include "integration/sampic/collector/sampic_collector.h"
#include "integration/sampic/collector/modes/sampic_collector_mode_default.h"
#include "integration/sampic/collector/modes/sampic_collector_mode_example.h"

SampicCollector::SampicCollector(const SampicCollectorConfig& cfg,
                                 CrateInfoStruct& info,
                                 CrateParamStruct& params,
                                 void* eventBuffer,
                                 ML_Frame* mlFrames)
    : cfg_(cfg),
      buffer_(std::make_unique<SampicEventBuffer>(cfg.buffer_size)) {
    switch (cfg.mode) {
        case SampicCollectorModeType::DEFAULT:
            mode_ = std::make_unique<SampicCollectorModeDefault>(info, params, eventBuffer, mlFrames, cfg);
            break;
        case SampicCollectorModeType::EXAMPLE:
            mode_ = std::make_unique<SampicCollectorModeExample>(info, params, eventBuffer, mlFrames, cfg);
            break;
        default:
            throw std::runtime_error("Unsupported SampicCollectorModeType");
    }
}

SampicCollector::~SampicCollector() {
    stop();
}

void SampicCollector::start() {
    if (running_) return;
    running_ = true;
    worker_ = std::thread(&SampicCollector::run, this);
}

void SampicCollector::stop() {
    if (running_) {
        running_ = false;
        if (worker_.joinable()) worker_.join();
    }
}

void SampicCollector::run() {
    spdlog::info("SAMPIC Collector started in mode {}", static_cast<int>(cfg_.mode));
    while (running_) {
        auto start_total = std::chrono::steady_clock::now();
        SampicEventTiming timing{};
        auto ev_ptr = std::make_shared<EventStruct>();

        int hits = mode_->readEvent(*ev_ptr, timing);

        auto end_total = std::chrono::steady_clock::now();
        timing.total_duration = std::chrono::duration_cast<std::chrono::microseconds>(end_total - start_total);

        if (hits > 0) {
            buffer_->push(ev_ptr, timing);
        }

        std::this_thread::sleep_for(std::chrono::microseconds(cfg_.sleep_time_us));
    }
    spdlog::info("SAMPIC Collector stopped");
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/collector/sampic_event_buffer.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/collector/sampic_event_buffer.cpp
Size: 2777 bytes
-----
#include "integration/sampic/collector/sampic_event_buffer.h"

SampicEventBuffer::SampicEventBuffer(size_t capacity)
    : capacity_(capacity),
      last_timestamp_(std::chrono::steady_clock::time_point::min()) {}

void SampicEventBuffer::push(const std::shared_ptr<EventStruct>& ev,
                             const SampicEventTiming& timing) {
    std::unique_lock<std::mutex> lock(mtx_);
    if (buffer_.size() >= capacity_) {
        const auto& oldest = buffer_.front();
        if (!oldest.consumed) {
            auto ts_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                             oldest.timestamp.time_since_epoch())
                             .count();
            spdlog::warn("SampicEventBuffer full ({}). Dropping UNCONSUMED event ts={} ns",
                         capacity_, ts_ns);
        }
        buffer_.pop_front();
    }
    buffer_.push_back(TimestampedSampicEvent{
        ev, std::chrono::steady_clock::now(), timing, false});
    last_timestamp_ = buffer_.back().timestamp;
    cv_.notify_all();
}

std::optional<TimestampedSampicEvent> SampicEventBuffer::pop() {
    std::unique_lock<std::mutex> lock(mtx_);
    if (buffer_.empty()) return std::nullopt;
    auto ev = buffer_.front();
    buffer_.pop_front();
    return ev;
}

std::optional<TimestampedSampicEvent> SampicEventBuffer::latest() {
    std::unique_lock<std::mutex> lock(mtx_);
    if (buffer_.empty()) return std::nullopt;
    auto& ev = buffer_.back();
    if (ev.consumed) {
        spdlog::warn("latest() returning already-consumed event");
    }
    ev.consumed = true;
    return ev;
}

std::vector<TimestampedSampicEvent>
SampicEventBuffer::getSince(std::chrono::steady_clock::time_point t) {
    std::unique_lock<std::mutex> lock(mtx_);
    std::vector<TimestampedSampicEvent> result;
    for (auto& ev : buffer_) {
        if (ev.timestamp > t) {
            if (ev.consumed) {
                spdlog::warn("getSince(): event already consumed");
            }
            ev.consumed = true;
            result.push_back(ev);
        }
    }
    return result;
}

bool SampicEventBuffer::hasNewSince(std::chrono::steady_clock::time_point t) const {
    std::unique_lock<std::mutex> lock(mtx_);
    return last_timestamp_ > t;
}

bool SampicEventBuffer::waitForNew(std::chrono::steady_clock::time_point t,
                                   std::chrono::milliseconds timeout) {
    std::unique_lock<std::mutex> lock(mtx_);
    return cv_.wait_for(lock, timeout, [&] {
        return last_timestamp_ > t;
    });
}

size_t SampicEventBuffer::size() const {
    std::unique_lock<std::mutex> lock(mtx_);
    return buffer_.size();
}

bool SampicEventBuffer::empty() const {
    std::unique_lock<std::mutex> lock(mtx_);
    return buffer_.empty();
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_board_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_board_configurator.cpp
Size: 3869 bytes
-----
// sampic_board_configurator.cpp
#include "integration/sampic/config/sampic_board_configurator.h"
#include "integration/sampic/config/sampic_chip_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>

// ------------------- Ctor -------------------
SampicBoardConfigurator::SampicBoardConfigurator(int boardIdx,
                                                 CrateInfoStruct& info,
                                                 CrateParamStruct& params,
                                                 SampicFrontEndConfig& config)
    : boardIdx_(boardIdx), info_(info), params_(params), config_(config) {}

// ------------------- Apply (board-level) -------------------
void SampicBoardConfigurator::apply() {
    spdlog::debug("Applying FEB {} settings...", boardIdx_);

    setGlobalTrigger();
    setLevel2ExtTrigGate();
    setLevel2Coincidence();

    applyChips();

    spdlog::debug("Finished applying FEB {}.", boardIdx_);
}

// ------------------- Settings -------------------
void SampicBoardConfigurator::setGlobalTrigger() {
    spdlog::trace("FEB {}: SetFrontEndBoardGlobalTriggerOption={}", 
                  boardIdx_, (int)config_.global_trigger_option);

    auto rc = SAMPIC256CH_SetFrontEndBoardGlobalTriggerOption(&info_, &params_,
                                                              boardIdx_,
                                                              config_.global_trigger_option);
    check(rc, "SetFrontEndBoardGlobalTriggerOption");
}

void SampicBoardConfigurator::setLevel2ExtTrigGate() {
    spdlog::trace("FEB {}: SetLevel2ExtTrigGate={}", 
                  boardIdx_, (int)config_.level2_ext_trig_gate);

    auto rc = SAMPIC256CH_SetLevel2ExtTrigGate(&info_, &params_,
                                               boardIdx_,
                                               config_.level2_ext_trig_gate);
    check(rc, "SetLevel2ExtTrigGate");
}

void SampicBoardConfigurator::setLevel2Coincidence() {
    spdlog::trace("FEB {}: SetLevel2CoincidenceModeWithExtTrigGate={}", 
                  boardIdx_, config_.level2_coincidence_ext_gate);

    auto rc = SAMPIC256CH_SetLevel2CoincidenceModeWithExtTrigGate(&info_, &params_,
                                                                  boardIdx_,
                                                                  config_.level2_coincidence_ext_gate);
    check(rc, "SetLevel2CoincidenceModeWithExtTrigGate");
}

// ------------------- Chips descend -------------------
void SampicBoardConfigurator::applyChips() {
    spdlog::debug("FEB {}: applying {} chips...", boardIdx_, config_.sampics.size());
    for (auto& [chipKey, chipCfg] : config_.sampics) {
        int chipIdx = indexFromKey(chipKey);

        if (!chipCfg.enabled) {
            spdlog::info("Skipping chip '{}' (FEB={}, idx={}) because it is disabled.",
                         chipKey, boardIdx_, chipIdx);
            continue;
        }

        spdlog::debug("  → Apply chip '{}'(index={})", chipKey, chipIdx);
        SampicChipConfigurator chip(boardIdx_, chipIdx, info_, params_, chipCfg);
        chip.apply();
    }
}

// ------------------- Utility -------------------
void SampicBoardConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error (FEB {}) in {} (code={})",
                      boardIdx_, what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

int SampicBoardConfigurator::indexFromKey(const std::string& key) {
    size_t pos = key.find_last_not_of("0123456789");
    if (pos == std::string::npos || pos + 1 >= key.size()) {
        throw std::runtime_error("Invalid config key: " + key);
    }
    return std::stoi(key.substr(pos + 1));
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_channel_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_channel_configurator.cpp
Size: 5349 bytes
-----
// sampic_channel_configurator.cpp
#include "integration/sampic/config/sampic_channel_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>

// ------------------- Ctor -------------------
SampicChannelConfigurator::SampicChannelConfigurator(int boardIdx,
                                                     int chipIdx,
                                                     int channelIdx,
                                                     CrateInfoStruct& info,
                                                     CrateParamStruct& params,
                                                     SampicChannelConfig& config)
    : boardIdx_(boardIdx), chipIdx_(chipIdx), channelIdx_(channelIdx),
      info_(info), params_(params), config_(config) {}

// ------------------- Apply (channel-level) -------------------
void SampicChannelConfigurator::apply() {
    spdlog::debug("Applying channel (FEB={}, chip={}, ch={}) settings...",
                  boardIdx_, chipIdx_, channelIdx_);

    setMode();
    setTriggerMode();
    setThreshold();
    setEdge();
    setExtThreshMode();
    setSourceForCT();
    setPulseMode();

    spdlog::debug("Finished applying channel (FEB={}, chip={}, ch={}).",
                  boardIdx_, chipIdx_, channelIdx_);
}

// ------------------- Settings -------------------
void SampicChannelConfigurator::setMode() {
    spdlog::trace("Channel (FEB={}, chip={}, ch={}): SetChannelMode={}",
                  boardIdx_, chipIdx_, channelIdx_, config_.enabled);

    auto rc = SAMPIC256CH_SetChannelMode(&info_, &params_,
                                         boardIdx_,
                                         (chipIdx_ * 16) + channelIdx_,
                                         config_.enabled);
    check(rc, "SetChannelMode");
}

void SampicChannelConfigurator::setTriggerMode() {
    spdlog::trace("Channel (FEB={}, chip={}, ch={}): SetSampicChannelTriggerMode={}",
                  boardIdx_, chipIdx_, channelIdx_, (int)config_.trigger_mode);

    auto rc = SAMPIC256CH_SetSampicChannelTriggerMode(&info_, &params_,
                                                      boardIdx_, chipIdx_, channelIdx_,
                                                      config_.trigger_mode);
    check(rc, "SetSampicChannelTriggerMode");
}

void SampicChannelConfigurator::setThreshold() {
    spdlog::trace("Channel (FEB={}, chip={}, ch={}): SetSampicChannelInternalThreshold={}",
                  boardIdx_, chipIdx_, channelIdx_, config_.internal_threshold);

    auto rc = SAMPIC256CH_SetSampicChannelInternalThreshold(&info_, &params_,
                                                            boardIdx_, chipIdx_, channelIdx_,
                                                            config_.internal_threshold);
    check(rc, "SetSampicChannelInternalThreshold");
}

void SampicChannelConfigurator::setEdge() {
    spdlog::trace("Channel (FEB={}, chip={}, ch={}): SetChannelSelfTriggerEdge={}",
                  boardIdx_, chipIdx_, channelIdx_, (int)config_.trigger_edge);

    auto rc = SAMPIC256CH_SetChannelSelflTriggerEdge(&info_, &params_,
                                                     boardIdx_, chipIdx_, channelIdx_,
                                                     config_.trigger_edge);
    check(rc, "SetChannelSelflTriggerEdge");
}

void SampicChannelConfigurator::setExtThreshMode() {
    spdlog::trace("Channel (FEB={}, chip={}): SetSampicExternalThresholdMode={}",
                  boardIdx_, chipIdx_, config_.external_threshold_mode);

    auto rc = SAMPIC256CH_SetSampicExternalThresholdMode(&info_, &params_,
                                                         boardIdx_, chipIdx_,
                                                         config_.external_threshold_mode);
    check(rc, "SetSampicExternalThresholdMode");
}

void SampicChannelConfigurator::setSourceForCT() {
    spdlog::trace("Channel (FEB={}, chip={}, ch={}): SetSampicChannelSourceForCT={}",
                  boardIdx_, chipIdx_, channelIdx_, config_.enable_for_central_trigger);

    auto rc = SAMPIC256CH_SetSampicChannelSourceForCT(&info_, &params_,
                                                      boardIdx_, chipIdx_, channelIdx_,
                                                      config_.enable_for_central_trigger);
    check(rc, "SetSampicChannelSourceForCT");
}

void SampicChannelConfigurator::setPulseMode() {
    spdlog::trace("Channel (FEB={}, chip={}, ch={}): SetSampicChannelPulseMode={}",
                  boardIdx_, chipIdx_, channelIdx_, config_.pulse_mode);

    auto rc = SAMPIC256CH_SetSampicChannelPulseMode(&info_, &params_,
                                                    boardIdx_, chipIdx_, channelIdx_,
                                                    config_.pulse_mode);
    check(rc, "SetSampicChannelPulseMode");
}

// ------------------- Utility -------------------
void SampicChannelConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error (FEB={}, chip={}, ch={}) in {} (code={})",
                      boardIdx_, chipIdx_, channelIdx_,
                      what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_chip_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_chip_configurator.cpp
Size: 7584 bytes
-----
// sampic_chip_configurator.cpp
#include "integration/sampic/config/sampic_chip_configurator.h"
#include "integration/sampic/config/sampic_channel_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>

// ------------------- Ctor -------------------
SampicChipConfigurator::SampicChipConfigurator(int boardIdx,
                                               int chipIdx,
                                               CrateInfoStruct& info,
                                               CrateParamStruct& params,
                                               SampicChipConfig& config)
    : boardIdx_(boardIdx), chipIdx_(chipIdx),
      info_(info), params_(params), config_(config) {}

// ------------------- Apply (chip-level) -------------------
void SampicChipConfigurator::apply() {
    spdlog::debug("Applying chip (FEB={}, chip={}) settings...", boardIdx_, chipIdx_);

    setBaseline();
    setExtThreshold();
    setTOTRange();
    setPostTrigger();

    setCentralTriggerMode();
    setCentralTriggerEffect();
    setCentralTriggerPrimitives();

    setTriggerOption();
    setTOTFilterParams();

    applyChannels();

    spdlog::debug("Finished applying chip (FEB={}, chip={}).", boardIdx_, chipIdx_);
}

// ------------------- Settings -------------------
void SampicChipConfigurator::setBaseline() {
    spdlog::trace("Chip (FEB={}, chip={}): SetBaselineReference={}",
                  boardIdx_, chipIdx_, config_.baseline_reference);
    auto rc = SAMPIC256CH_SetBaselineReference(&info_, &params_,
                                               boardIdx_, chipIdx_,
                                               config_.baseline_reference);
    check(rc, "SetBaselineReference");
}

void SampicChipConfigurator::setExtThreshold() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicExternalThreshold={}",
                  boardIdx_, chipIdx_, config_.external_threshold);
    auto rc = SAMPIC256CH_SetSampicExternalThreshold(&info_, &params_,
                                                     boardIdx_, chipIdx_,
                                                     config_.external_threshold);
    check(rc, "SetSampicExternalThreshold");
}

void SampicChipConfigurator::setTOTRange() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicTOTRange={}",
                  boardIdx_, chipIdx_, (int)config_.tot_range);
    auto rc = SAMPIC256CH_SetSampicTOTRange(&info_, &params_,
                                            boardIdx_, chipIdx_,
                                            config_.tot_range);
    check(rc, "SetSampicTOTRange");
}

void SampicChipConfigurator::setPostTrigger() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicPostTrigParams enable={}, value={}",
                  boardIdx_, chipIdx_, config_.enable_post_trigger, config_.post_trigger_value);
    auto rc = SAMPIC256CH_SetSampicPostTrigParams(&info_, &params_,
                                                  boardIdx_, chipIdx_,
                                                  config_.enable_post_trigger,
                                                  config_.post_trigger_value);
    check(rc, "SetSampicPostTrigParams");
}

void SampicChipConfigurator::setCentralTriggerMode() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicCentralTriggerMode={}",
                  boardIdx_, chipIdx_, (int)config_.central_trigger_mode);
    auto rc = SAMPIC256CH_SetSampicCentralTriggerMode(&info_, &params_,
                                                      boardIdx_, chipIdx_,
                                                      config_.central_trigger_mode);
    check(rc, "SetSampicCentralTriggerMode");
}

void SampicChipConfigurator::setCentralTriggerEffect() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicCentralTriggerEffect={}",
                  boardIdx_, chipIdx_, (int)config_.central_trigger_effect);
    auto rc = SAMPIC256CH_SetSampicCentralTriggerEffect(&info_, &params_,
                                                        boardIdx_, chipIdx_,
                                                        config_.central_trigger_effect);
    check(rc, "SetSampicCentralTriggerEffect");
}

void SampicChipConfigurator::setCentralTriggerPrimitives() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicCentralTriggerPrimitivesOptions mode={}, gate_len={}",
                  boardIdx_, chipIdx_, (int)config_.primitives_mode, config_.primitives_gate_length);
    auto rc = SAMPIC256CH_SetSampicCentralTriggerPrimitivesOptions(&info_, &params_,
                                                                   boardIdx_, chipIdx_,
                                                                   config_.primitives_mode,
                                                                   config_.primitives_gate_length);
    check(rc, "SetSampicCentralTriggerPrimitivesOptions");
}

void SampicChipConfigurator::setTriggerOption() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicTriggerOption={}",
                  boardIdx_, chipIdx_, (int)config_.central_trigger_mode);
    auto rc = SAMPIC256CH_SetSampicTriggerOption(&info_, &params_,
                                                 boardIdx_, chipIdx_,
                                                 SAMPIC_TRIGGER_IS_L1); // TODO: map properly if needed
    check(rc, "SetSampicTriggerOption");
}

void SampicChipConfigurator::setTOTFilterParams() {
    spdlog::trace("Chip (FEB={}, chip={}): SetSampicTOTFilterParams en={}, wide={}, minWidthNs={}",
                  boardIdx_, chipIdx_,
                  config_.tot_filter_enable,
                  config_.tot_wide_cap,
                  config_.tot_min_width_ns);
    auto rc = SAMPIC256CH_SetSampicTOTFilterParams(&info_, &params_,
                                                   boardIdx_, chipIdx_,
                                                   config_.tot_filter_enable,
                                                   config_.tot_wide_cap,
                                                   config_.tot_min_width_ns);
    check(rc, "SetSampicTOTFilterParams");
}

// ------------------- Channels descend -------------------
void SampicChipConfigurator::applyChannels() {
    spdlog::debug("Chip (FEB={}, chip={}): applying {} channels...",
                  boardIdx_, chipIdx_, config_.channels.size());
    for (auto& [chKey, chCfg] : config_.channels) {
        int chIdx = indexFromKey(chKey);

        if (!chCfg.enabled) {
            spdlog::info("Skipping channel '{}' (FEB={}, chip={}, idx={}) because it is disabled.",
                         chKey, boardIdx_, chipIdx_, chIdx);
            continue;
        }

        spdlog::debug("  → Apply channel '{}'(index={})", chKey, chIdx);
        SampicChannelConfigurator ch(boardIdx_, chipIdx_, chIdx, info_, params_, chCfg);
        ch.apply();
    }
}

// ------------------- Utility -------------------
void SampicChipConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error (FEB={}, chip={}) in {} (code={})",
                      boardIdx_, chipIdx_, what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

int SampicChipConfigurator::indexFromKey(const std::string& key) {
    size_t pos = key.find_last_not_of("0123456789");
    if (pos == std::string::npos || pos + 1 >= key.size()) {
        throw std::runtime_error("Invalid config key: " + key);
    }
    return std::stoi(key.substr(pos + 1));
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/config/sampic_crate_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/config/sampic_crate_configurator.cpp
Size: 12340 bytes
-----
// sampic_crate_configurator.cpp
#include "integration/sampic/config/sampic_crate_configurator.h"
#include "integration/sampic/config/sampic_board_configurator.h"

#include <spdlog/spdlog.h>
#include <stdexcept>
#include <string>

// ------------------- Ctor -------------------
SampicCrateConfigurator::SampicCrateConfigurator(CrateInfoStruct& info,
                                                 CrateParamStruct& params,
                                                 SampicSystemSettings& settings)
    : info_(info), params_(params), settings_(settings) {}

// ------------------- Apply (top-level) -------------------
void SampicCrateConfigurator::apply() {
    spdlog::info("Applying SAMPIC crate settings...");

    // Acquisition
    setSamplingFrequency();
    setADCBits();
    setFramesPerBlock();
    setTOTMode();
    setSmartReadMode();

    // External trigger & build logic
    setExternalTriggerType();
    setExternalTriggerLevel();
    setExternalTriggerEdge();
    setMinTriggersPerEvent();
    setLevel2TriggerBuild();
    setLevel3TriggerBuild();

    // Global gates
    setPrimitivesGateLength();
    setLevel2LatencyGateLength();
    setLevel3ExtTrigGate();
    setLevel3CoincidenceWithExtGate();

    // Pulser
    setPulser();

    // Sync & corrections
    setSyncMode();
    setSyncEdge();
    setSyncLevel();
    setCorrectionLevels();

    // Descend to boards/chips/channels
    applyBoards();

    spdlog::info("SAMPIC crate settings applied.");
}

// ------------------- Acquisition -------------------
void SampicCrateConfigurator::setSamplingFrequency() {
    spdlog::debug("SetSamplingFrequency: {} MS/s (use_external_clock={})",
                  settings_.sampling_frequency_mhz, settings_.use_external_clock);
    auto rc = SAMPIC256CH_SetSamplingFrequency(&info_, &params_,
                                               settings_.sampling_frequency_mhz,
                                               settings_.use_external_clock);
    check(rc, "SetSamplingFrequency");
}

void SampicCrateConfigurator::setFramesPerBlock() {
    spdlog::debug("SetNbOfFramesPerBlock: {}", settings_.frames_per_block);
    auto rc = SAMPIC256CH_SetNbOfFramesPerBlock(&info_, &params_, settings_.frames_per_block);
    check(rc, "SetNbOfFramesPerBlock");
}

void SampicCrateConfigurator::setTOTMode() {
    spdlog::debug("SetTOTMeasurementMode: {}", settings_.enable_tot);
    auto rc = SAMPIC256CH_SetTOTMeasurementMode(&info_, &params_, settings_.enable_tot);
    check(rc, "SetTOTMeasurementMode");
}

void SampicCrateConfigurator::setADCBits() {
    spdlog::debug("Set_SystemADCNbOfBits: {}", settings_.adc_bits);
    auto rc = Set_SystemADCNbOfBits(&info_, &params_, settings_.adc_bits);
    check(rc, "Set_SystemADCNbOfBits");
}

void SampicCrateConfigurator::setSmartReadMode() {
    spdlog::debug("SetSmartReadMode: mode={}, samples={}, offset={}",
                  settings_.smart_read_mode, settings_.samples_to_read, settings_.read_offset);
    auto rc = SAMPIC256CH_SetSmartReadMode(&info_, &params_,
                                           settings_.smart_read_mode,
                                           settings_.samples_to_read,
                                           settings_.read_offset);
    check(rc, "SetSmartReadMode");
}

// ------------------- External trigger + build -------------------
void SampicCrateConfigurator::setExternalTriggerType() {
    spdlog::debug("SetExternalTriggerType: {}", (int)settings_.external_trigger_type);
    auto rc = SAMPIC256CH_SetExternalTriggerType(&info_, &params_, settings_.external_trigger_type);
    check(rc, "SetExternalTriggerType");
}

void SampicCrateConfigurator::setExternalTriggerLevel() {
    spdlog::debug("SetExternalTriggerSigLevel: {}", (int)settings_.signal_level);
    auto rc = SAMPIC256CH_SetExternalTriggerSigLevel(&info_, &params_, settings_.signal_level);
    check(rc, "SetExternalTriggerSigLevel");
}

void SampicCrateConfigurator::setExternalTriggerEdge() {
    spdlog::debug("SetExternalTriggerEdge: {}", (int)settings_.trigger_edge);
    auto rc = SAMPIC256CH_SetExternalTriggerEdge(&info_, &params_, settings_.trigger_edge);
    check(rc, "SetExternalTriggerEdge");
}

void SampicCrateConfigurator::setMinTriggersPerEvent() {
    spdlog::debug("SetMinNbOfTriggersPerEvent: {}", (int)settings_.triggers_per_event);
    auto rc = SAMPIC256CH_SetMinNbOfTriggersPerEvent(&info_, &params_,
                                                     (unsigned char)settings_.triggers_per_event);
    check(rc, "SetMinNbOfTriggersPerEvent");
}

void SampicCrateConfigurator::setLevel2TriggerBuild() {
    spdlog::debug("SetLevel2TriggerBuildOption: {}", settings_.level2_trigger_build);
    auto rc = SAMPIC256CH_SetLevel2TriggerBuildOption(&info_, &params_, settings_.level2_trigger_build);
    check(rc, "SetLevel2TriggerBuildOption");
}

void SampicCrateConfigurator::setLevel3TriggerBuild() {
    spdlog::debug("SetLevel3TriggerLogic: enable={}", settings_.level3_trigger_build);
    TriggerLogicParamStruct l3params{}; // default params if none provided in settings
    auto rc = SAMPIC256CH_SetLevel3TriggerLogic(&info_, &params_,
                                                settings_.level3_trigger_build, l3params);
    check(rc, "SetLevel3TriggerLogic");
}

// ------------------- Global gates -------------------
void SampicCrateConfigurator::setPrimitivesGateLength() {
    spdlog::debug("SetPrimitivesGateLength: {}", (int)settings_.primitives_gate_length);
    auto rc = SAMPIC256CH_SetPrimitivesGateLength(&info_, &params_,
                                                  (unsigned char)settings_.primitives_gate_length);
    check(rc, "SetPrimitivesGateLength");
}

void SampicCrateConfigurator::setLevel2LatencyGateLength() {
    spdlog::debug("SetLevel2LatencyGateLength: {}", (int)settings_.latency_gate_length);
    auto rc = SAMPIC256CH_SetLevel2LatencyGateLength(&info_, &params_,
                                                     (unsigned char)settings_.latency_gate_length);
    check(rc, "SetLevel2LatencyGateLength");
}

void SampicCrateConfigurator::setLevel3ExtTrigGate() {
    spdlog::debug("SetLevel3ExtTrigGate: {}", (int)settings_.level3_ext_trig_gate);
    auto rc = SAMPIC256CH_SetLevel3ExtTrigGate(&info_, &params_,
                                               (unsigned char)settings_.level3_ext_trig_gate);
    check(rc, "SetLevel3ExtTrigGate");
}

void SampicCrateConfigurator::setLevel3CoincidenceWithExtGate() {
    spdlog::debug("SetLevel3CoincidenceModeWithExtTrigGate: {}", settings_.level3_coincidence_ext_gate);
    auto rc = SAMPIC256CH_SetLevel3CoincidenceModeWithExtTrigGate(&info_, &params_,
                                                                  settings_.level3_coincidence_ext_gate);
    check(rc, "SetLevel3CoincidenceModeWithExtTrigGate");
}

// ------------------- Pulser -------------------
void SampicCrateConfigurator::setPulser() {
    spdlog::debug("SetPulserMode: enable={}, src={}, sync={}",
                  settings_.pulser_enable, (int)settings_.pulser_source, settings_.pulser_synchronous);
    auto rc = SAMPIC256CH_SetPulserMode(&info_, &params_,
                                        settings_.pulser_enable,
                                        settings_.pulser_source,
                                        settings_.pulser_synchronous);
    check(rc, "SetPulserMode");

    spdlog::debug("SetAutoPulserPeriod: {}", settings_.pulser_period);
    rc = SAMPIC256CH_SetAutoPulserPeriod(&info_, &params_, settings_.pulser_period);
    check(rc, "SetAutoPulserPeriod");

    // NOTE: pulser width is a per-chip setting in the C API; apply across all (board, chip).
    for (const auto& [febKey, febCfg] : settings_.front_end_boards) {
        int febIdx = indexFromKey(febKey);
        // We’ll apply the *crate-level* width to every chip unless a chip-level configurator later overrides it.
        for (const auto& [chipKey, chipCfg] : febCfg.sampics) {
            int chipIdx = indexFromKey(chipKey);
            spdlog::trace("SetSampicPulserWidth: feb={}, chip={}, width={}",
                          febIdx, chipIdx, (int)settings_.pulser_width);
            auto rc2 = SAMPIC256CH_SetSampicPulserWidth(&info_, &params_, febIdx, chipIdx,
                                                        (unsigned char)settings_.pulser_width);
            check(rc2, "SetSampicPulserWidth");
        }
    }
}

// ------------------- Sync + corrections -------------------
void SampicCrateConfigurator::setSyncMode() {
    spdlog::debug("SetCrateSycnhronisationMode: sync={}, master={}, coinc={}",
                  settings_.sync_mode, settings_.master_mode, settings_.coincidence_mode);
    auto rc = SAMPIC256CH_SetCrateSycnhronisationMode(&info_, &params_,
                                                      settings_.sync_mode,
                                                      settings_.master_mode,
                                                      settings_.coincidence_mode);
    check(rc, "SetCrateSycnhronisationMode");
}

void SampicCrateConfigurator::setSyncEdge() {
    spdlog::debug("SetExternalSyncEdge: {}", (int)settings_.sync_edge);
    auto rc = SAMPIC256CH_SetExternalSyncEdge(&info_, &params_, settings_.sync_edge);
    check(rc, "SetExternalSyncEdge");
}

void SampicCrateConfigurator::setSyncLevel() {
    spdlog::debug("SetExternalSyncSigLevel: {}", (int)settings_.sync_level);
    auto rc = SAMPIC256CH_SetExternalSyncSigLevel(&info_, &params_, settings_.sync_level);
    check(rc, "SetExternalSyncSigLevel");
}

void SampicCrateConfigurator::setCorrectionLevels() {
    spdlog::debug("SetCrateCorrectionLevels: adc={}, inl={}, ped={}",
                  settings_.adc_linearity_correction,
                  settings_.time_inl_correction,
                  settings_.residual_pedestal_correction);
    auto rc = SAMPIC256CH_SetCrateCorrectionLevels(&info_, &params_,
                                                   settings_.adc_linearity_correction,
                                                   settings_.time_inl_correction,
                                                   settings_.residual_pedestal_correction);
    check(rc, "SetCrateCorrectionLevels");

    // Optional: auto-load all calibration values if directory provided (non-empty)
    if (!settings_.calibration_directory.empty()) {
        spdlog::debug("LoadAllCalibValuesFromFiles: dir='{}'", settings_.calibration_directory);
        char dirbuf[MAX_PATHNAME_LENGTH] = {0};
        std::snprintf(dirbuf, sizeof(dirbuf), "%s", settings_.calibration_directory.c_str());
        auto rc2 = SAMPIC256CH_LoadAllCalibValuesFromFiles(&info_, &params_, dirbuf);
        if (rc2 != SAMPIC256CH_Success) {
            // Not fatal for general operation; log and continue (some users don't ship full calib sets).
            spdlog::warn("LoadAllCalibValuesFromFiles failed (code={}), continuing without file-based calib.",
                         (int)rc2);
        }
    }
}

// ------------------- Boards descend -------------------
void SampicCrateConfigurator::applyBoards() {
    spdlog::debug("Applying front-end boards settings...");
    for (auto& [key, febCfg] : settings_.front_end_boards) {
        int febIdx = indexFromKey(key);

        if (!febCfg.enabled) {
            spdlog::info("Skipping FEB '{}' (index={}) because it is disabled.", key, febIdx);
            continue;
        }

        spdlog::debug("Apply FEB '{}'(index={})", key, febIdx);
        SampicBoardConfigurator feb(febIdx, info_, params_, febCfg);
        feb.apply();
    }
    spdlog::debug("Front-end boards applied.");
}

// ------------------- Utility -------------------
void SampicCrateConfigurator::check(SAMPIC256CH_ErrCode code, const std::string& what) {
    if (code != SAMPIC256CH_Success) {
        spdlog::error("SAMPIC error in {} (code={})", what, static_cast<int>(code));
        throw std::runtime_error("SAMPIC error in " + what +
                                 " (code " + std::to_string(code) + ")");
    }
}

int SampicCrateConfigurator::indexFromKey(const std::string& key) {
    size_t pos = key.find_last_not_of("0123456789");
    if (pos == std::string::npos || pos + 1 >= key.size()) {
        throw std::runtime_error("Invalid config key: " + key);
    }
    return std::stoi(key.substr(pos + 1));
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.cpp
Size: 737 bytes
-----
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h"
#include "integration/sampic/config/sampic_crate_configurator.h"
#include <spdlog/spdlog.h>

void SampicApplySettingsModeDefault::apply() {
    spdlog::info("ApplySettingsModeDefault: Applying full crate configuration...");

    try {
        // Use the configurator to apply *everything* from settings_
        SampicCrateConfigurator crateCfg(info_, params_, settings_);
        crateCfg.apply();

        spdlog::info("ApplySettingsModeDefault: All settings applied successfully.");
    } catch (const std::exception& e) {
        spdlog::error("ApplySettingsModeDefault: Exception during apply: {}", e.what());
        throw;
    }
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.cpp
Size: 2592 bytes
-----
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h"
#include "integration/sampic/config/sampic_crate_configurator.h"
#include "integration/sampic/config/sampic_board_configurator.h"
#include "integration/sampic/config/sampic_chip_configurator.h"
#include "integration/sampic/config/sampic_channel_configurator.h"
#include <spdlog/spdlog.h>

void SampicApplySettingsModeExample::apply() {
    spdlog::info("ApplySettingsModeExample: Setting trigger options...");

    try {
        // --- Crate-level ---
        SampicCrateConfigurator crateCfg(info_, params_, settings_);
        crateCfg.setExternalTriggerType();

        // --- Loop over boards / chips / channels ---
        for (auto& [boardKey, boardCfg] : settings_.front_end_boards) {
            if (!boardCfg.enabled) {
                spdlog::debug("Skipping disabled board '{}'", boardKey);
                continue;
            }

            int boardIdx = crateCfg.indexFromKey(boardKey);
            SampicBoardConfigurator boardConfigurator(boardIdx, info_, params_, boardCfg);

            for (auto& [chipKey, chipCfg] : boardCfg.sampics) {
                if (!chipCfg.enabled) {
                    spdlog::debug("Skipping disabled chip '{}:{}'", boardKey, chipKey);
                    continue;
                }

                int chipIdx = boardConfigurator.indexFromKey(chipKey);
                SampicChipConfigurator chipConfigurator(boardIdx, chipIdx, info_, params_, chipCfg);

                // SAMPIC_TRIGGER_IS_L1
                chipConfigurator.setTriggerOption();

                for (auto& [chKey, chCfg] : chipCfg.channels) {
                    if (!chCfg.enabled) {
                        spdlog::trace("Skipping disabled channel '{}:{}:{}'",
                                      boardKey, chipKey, chKey);
                        continue;
                    }

                    int chIdx = chipConfigurator.indexFromKey(chKey);
                    SampicChannelConfigurator chConfigurator(boardIdx, chipIdx, chIdx,
                                                             info_, params_, chCfg);

                    // Enable channel + set EXT_TRIGGER_MODE
                    chConfigurator.setMode();
                    chConfigurator.setTriggerMode();
                }
            }
        }

        spdlog::info("ApplySettingsModeExample: Trigger options set successfully.");

    } catch (const std::exception& e) {
        spdlog::error("ApplySettingsModeExample: Exception during apply: {}", e.what());
        throw;
    }
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.cpp
Size: 1893 bytes
-----
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h"
#include <spdlog/spdlog.h>
#include <cstring>

int SampicInitSettingsModeDefault::initialize() {
    spdlog::info("InitSettingsModeDefault: Initializing SAMPIC system...");

    CrateConnectionParamStruct conn{};
    conn.ConnectionType = settings_.connection_type;
    conn.ControlBoardControlType = settings_.control_type;
    strncpy(conn.CtrlIpAddress, settings_.ip_address.c_str(), sizeof(conn.CtrlIpAddress) - 1);
    conn.CtrlIpAddress[sizeof(conn.CtrlIpAddress) - 1] = '\0';
    conn.CtrlPort = settings_.port;

    auto err = SAMPIC256CH_OpenCrateConnection(conn, &info_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeDefault: Failed to open crate connection (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeDefault: Connection opened with {} FE boards.", info_.NbOfFeBoards);

    err = SAMPIC256CH_SetDefaultParameters(&info_, &params_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeDefault: Failed to open crate connection (err={})", static_cast<int>(err));
        return err;
    }

    err = SAMPIC256CH_LoadAllCalibValuesFromFiles(&info_, &params_,
                                                  const_cast<char*>(settings_.calibration_directory.c_str()));
    if (err != SAMPIC256CH_Success) {
        spdlog::warn("InitSettingsModeDefault: Calibration files missing, continuing anyway...");
    }

    err = SAMPIC256CH_AllocateEventMemory(&eventBuffer_, &mlFrames_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeDefault: Failed to allocate event memory (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeDefault: Event memory allocated successfully.");

    return SAMPIC256CH_Success;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.cpp
Size: 1894 bytes
-----
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h"
#include <spdlog/spdlog.h>
#include <cstring>

int SampicInitSettingsModeExample::initialize() {
    spdlog::info("InitSettingsModeExample: Initializing SAMPIC system...");

    CrateConnectionParamStruct conn{};
    conn.ConnectionType = settings_.connection_type;
    conn.ControlBoardControlType = settings_.control_type;
    strncpy(conn.CtrlIpAddress, settings_.ip_address.c_str(), sizeof(conn.CtrlIpAddress) - 1);
    conn.CtrlIpAddress[sizeof(conn.CtrlIpAddress) - 1] = '\0';
    conn.CtrlPort = settings_.port;

    auto err = SAMPIC256CH_OpenCrateConnection(conn, &info_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeExample: Failed to open crate connection (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeExample: Connection opened with {} FE boards.", info_.NbOfFeBoards);

    err = SAMPIC256CH_SetDefaultParameters(&info_, &params_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeExample: Failed to set default parameters (err={})", static_cast<int>(err));
        return err;
    }

    err = SAMPIC256CH_LoadAllCalibValuesFromFiles(&info_, &params_,
                                                  const_cast<char*>(settings_.calibration_directory.c_str()));
    if (err != SAMPIC256CH_Success) {
        spdlog::warn("InitSettingsModeExample: Calibration files missing, continuing anyway...");
    }

    err = SAMPIC256CH_AllocateEventMemory(&eventBuffer_, &mlFrames_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("InitSettingsModeExample: Failed to allocate event memory (err={})", static_cast<int>(err));
        return err;
    }
    spdlog::info("InitSettingsModeExample: Event memory allocated successfully.");

    return SAMPIC256CH_Success;
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/sampic/controller/sampic_controller.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/sampic/controller/sampic_controller.cpp
Size: 5825 bytes
-----
#include "integration/sampic/controller/sampic_controller.h"
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_default.h"
#include "integration/sampic/controller/init_settings_modes/sampic_init_settings_mode_example.h"
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_default.h"
#include "integration/sampic/controller/apply_settings_modes/sampic_apply_settings_mode_example.h"

SampicController::SampicController(const SampicSystemSettings& sys_cfg,
                                   const SampicControllerConfig& ctrl_cfg,
                                   const SampicCollectorConfig& coll_cfg)
    : settings_(sys_cfg),
      ctrl_cfg_(ctrl_cfg),
      coll_cfg_(coll_cfg)
{
    // Select init mode
    switch (ctrl_cfg_.init_mode) {
        case SampicInitSettingsModeType::DEFAULT:
            init_mode_ = std::make_unique<SampicInitSettingsModeDefault>(
                info_, params_, eventBuffer_, mlFrames_, settings_, ctrl_cfg_);
            break;
        case SampicInitSettingsModeType::EXAMPLE:
            init_mode_ = std::make_unique<SampicInitSettingsModeExample>(
                info_, params_, eventBuffer_, mlFrames_, settings_, ctrl_cfg_);
            break;
    }

    // Select apply mode
    switch (ctrl_cfg_.apply_mode) {
        case SampicApplySettingsModeType::DEFAULT:
            apply_mode_ = std::make_unique<SampicApplySettingsModeDefault>(
                info_, params_, settings_, ctrl_cfg_);
            break;
        case SampicApplySettingsModeType::EXAMPLE:
            apply_mode_ = std::make_unique<SampicApplySettingsModeExample>(
                info_, params_, settings_, ctrl_cfg_);
            break;
    }

    // Create collector (owns its buffer)
    collector_ = std::make_unique<SampicCollector>(
        coll_cfg_, info_, params_, eventBuffer_, mlFrames_);
}

SampicController::~SampicController() {
    try {
        stopCollector();
        stopRun();
        cleanup();
    } catch (...) {
        // swallow errors in destructor
    }
}

// ---------------- Config management ----------------
void SampicController::setSystemSettings(const SampicSystemSettings& s) { settings_ = s; }
SampicSystemSettings& SampicController::systemSettings() { return settings_; }
const SampicSystemSettings& SampicController::systemSettings() const { return settings_; }

void SampicController::setControllerConfig(const SampicControllerConfig& c) { ctrl_cfg_ = c; }
SampicControllerConfig& SampicController::controllerConfig() { return ctrl_cfg_; }
const SampicControllerConfig& SampicController::controllerConfig() const { return ctrl_cfg_; }

void SampicController::setCollectorConfig(const SampicCollectorConfig& c) { coll_cfg_ = c; }
SampicCollectorConfig& SampicController::collectorConfig() { return coll_cfg_; }
const SampicCollectorConfig& SampicController::collectorConfig() const { return coll_cfg_; }

// ---------------- Lifecycle ----------------
int SampicController::initialize() {
    if (!init_mode_) {
        spdlog::error("Init mode not configured");
        return -1;
    }
    int rc = init_mode_->initialize();
    initialized_ = (rc == SAMPIC256CH_Success);
    return rc;
}

int SampicController::applySettings() {
    if (!apply_mode_) {
        spdlog::error("Apply mode not configured");
        return -1;
    }
    try {
        // Apply hardware settings
        apply_mode_->apply();

        // Rebuild collector with updated config
        stopCollector();
        collector_.reset();
        collector_ = std::make_unique<SampicCollector>(
            coll_cfg_, info_, params_, eventBuffer_, mlFrames_);

        spdlog::info("Collector rebuilt with new configuration");
        return 0;
    } catch (const std::exception& e) {
        spdlog::error("Apply settings failed: {}", e.what());
        return -1;
    }
}

int SampicController::startRun() {
    if (run_started_) {
        spdlog::warn("startRun() called but run already started");
        return 0;
    }

    spdlog::info("Starting SAMPIC run...");
    auto err = SAMPIC256CH_StartRun(&info_, &params_, TRUE);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("Failed to start run (err={})", static_cast<int>(err));
        return err;
    }
    run_started_ = true;
    return 0;
}

int SampicController::stopRun() {
    if (!run_started_) {
        spdlog::debug("stopRun() called but run was not started — skipping");
        return 0;
    }

    spdlog::info("Stopping SAMPIC run...");
    auto err = SAMPIC256CH_StopRun(&info_, &params_);
    if (err != SAMPIC256CH_Success) {
        spdlog::error("Failed to stop run (err={})", static_cast<int>(err));
        return err;
    }
    run_started_ = false;
    return 0;
}

void SampicController::cleanup() {
    if (!initialized_) {
        spdlog::debug("cleanup() called but controller not initialized — skipping");
        return;
    }

    spdlog::info("Cleaning up SAMPIC resources...");
    if (eventBuffer_ || mlFrames_) {
        SAMPIC256CH_FreeEventMemory(&eventBuffer_, &mlFrames_);
        eventBuffer_ = nullptr;
        mlFrames_ = nullptr;
    }
    SAMPIC256CH_CloseCrateConnection(&info_);
    initialized_ = false;
}

// ---------------- Collector ----------------
void SampicController::startCollector() {
    if (collector_ && !collector_running_) {
        collector_->start();
        collector_running_ = true;
    }
}
void SampicController::stopCollector() {
    if (collector_ && collector_running_) {
        collector_->stop();
        collector_running_ = false;
    }
}

// ---------------- Buffer access ----------------
SampicEventBuffer& SampicController::buffer() {
    return collector_->buffer();
}
const SampicEventBuffer& SampicController::buffer() const {
    return collector_->buffer();
}

===== FILE END =====

===== FILE START =====
Relative Path: src/integration/splog/logger_configurator.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/integration/splog/logger_configurator.cpp
Size: 1241 bytes
-----
#include "integration/spdlog/logger_configurator.h"

#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/spdlog.h>

void LoggerConfigurator::configure(const LoggerConfig& cfg) {
    std::vector<spdlog::sink_ptr> sinks;

    if (cfg.to_console) {
        sinks.push_back(std::make_shared<spdlog::sinks::stdout_color_sink_mt>());
    }

    if (cfg.to_file) {
        sinks.push_back(std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
            cfg.log_file, cfg.max_file_size, cfg.max_files));
    }

    if (sinks.empty()) {
        // fallback to console if nothing is selected
        sinks.push_back(std::make_shared<spdlog::sinks::stdout_color_sink_mt>());
    }

    auto logger = std::make_shared<spdlog::logger>(cfg.name, sinks.begin(), sinks.end());

    // Apply pattern and level
    logger->set_pattern(cfg.log_pattern);
    auto level = spdlog::level::from_str(cfg.log_level);
    logger->set_level(level);
    logger->flush_on(spdlog::level::err);

    // Install as global default logger
    spdlog::set_default_logger(logger);
    spdlog::set_level(level); // global filter level

    spdlog::info("Logger '{}' initialized at level {}", cfg.name, cfg.log_level);
}
===== FILE END =====

===== FILE START =====
Relative Path: src/processing/sampic_processing/collector/frontend_event_buffer.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/processing/sampic_processing/collector/frontend_event_buffer.cpp
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: src/processing/sampic_processing/collector/frontend_event_collector.h
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/processing/sampic_processing/collector/frontend_event_collector.h
Size: 0 bytes
-----

===== FILE END =====

===== FILE START =====
Relative Path: src/processing/sampic_processing/config/frontend_event_collector_config.cpp
Absolute Path: /home/pioneer/jcarlton/projects/midas_sampic/experiments/sampic_daq/src/processing/sampic_processing/config/frontend_event_collector_config.cpp
Size: 0 bytes
-----

===== FILE END =====

